<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="description" content="most opinionated blog"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/blog/rss.xml" title="devthewild" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>translation - devthewild</title><link rel="stylesheet" href="/blog/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"><a href="/blog/">devthewild</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/blog/" class="head-nav__link">Home</a></li><li class="head-nav__item"><a href="/blog/archives" class="head-nav__link">Archives</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2015-05-28T00:39:49.000Z" class="post__time">28th May, 2015</time><h1 class="post__title"><a href="/blog/2015/05/28/callback-to-future-functor-applicative-monad/">Callback에서 Future로(그리고 Functor, Monad)</a></h1></header><div class="post__main echo"><blockquote>
<h3>Translation of &quot;<a href="http://tech.pro/blog/6742/callback-to-future-functor-applicative-monad" target="_blank" rel="external">From callback to (Future -&gt; Functor -&gt; Monad)</a>&quot; into Korean, under the same license as the original.</h3>
</blockquote>
<h2>동기</h2>
<p>함수형 프로그래밍에서 기본개념은 <strong>조합(composition)</strong> 이다. 간단히 설명해서, 단순한 것들을 엮어서 더
복잡한 것을 만들 수 있고 그 결과를 다시 엮어서 더 복잡한 것을 만들 수도 있다. 함수의 의미나 리턴값이
무엇인지만 알고 있으면 조합으로 무엇이든 만들어낼 수 있다.</p>
<p>Node.js를 써봤으면 아래와 같은코드를 본 적이 있을 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'...'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  ....</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>위의 코드는 전형적인 CPS(continuation-passing style) 함수이다. <code>fs.readFile</code>이라는 CPS
함수는 계속(continuation) 진행될 콜백을 추가 파라미터로 받는다. 이 CPS가 끝나면 호출한 곳에 값을
반환하는게 아니라 계속 함수, 콜백에 계산 결과를 넘겨준다.</p>
<p>나는 콜백을 쓰는걸 꺼리진 않는다. 사실 콜백은 부수효과를 표현하거나 이벤트 알림같은 것을 다룰 때
훌륭하다. 그렇지만 그걸로 흐름을 관리하기 시작하면 함정에 빠진 것이다. 왜냐면 조합할 수 없기 때문에.</p>
<p>자, 생각해보자. &quot;위에 나온 함수의 **표기(denotation)**나 리턴값은 무슨 의미일까?&quot; 답은
<code>undefined</code>이다. undefined라는건 테스트할 때 실제로 undefined인지 확인하는 용도 이외에는 쓸
데가 없다.</p>
<p>콜백 안에서 다른 실행 흐름으로 넘어갈 때 일방통행이라는게 문제다.</p>
<p>물리학에서 유명한 블랙홀처럼 콜백을 생각해보자:</p>
<blockquote>
<p>블랙홀은 수학적으로 정의된 지역이다. 강한 인력이 작용하거나, 어떤 티끌이나 전자기적 파장조차
빠져나갈 수 없는</p>
</blockquote>
<p>그 중에서도</p>
<blockquote>
<p>어떤 빛도 반사하지 않는 등 블랙홀은 많은 부분에서 이상적인 검은 물체처럼 작용한다.</p>
</blockquote>
<p>콜백 함수 또한 흐름에서의 어떤 것도 반사하지 못한다.</p>
<p>나중에 첫번째 콜백에 들어갈 때 다른 콜백 스타일 함수를 쓸 수 있는데, 그때는 두번째 <strong>흐름</strong>을 잃게
되고 다른 구멍에 빠지게 된다. 콜백을 쓰면 쓸 수록 지옥에 빠지게 된다.</p>
<p>그럼 블랙홀에 빠지지 않고 코드를 진행할 수는 없을까?</p>
<p>답은 <strong>조합</strong>이다. 하지만 조합을 사용하려면 일단 CPS 함수가 어디로도 돌아갈 수 없다는 사실을
알아야하고, 함수로부터 뭔가를 받아와야한다. 그러니 어떻게든 함수가 뭔가를 반환하게 만들어야한다. 어떤
값이 반환될까? 이게 이 글의 동기이다.</p>
<p>이미 자바스크립트에서의 해답을 알고 있을 수 있다. 하지만 계속 이 글을 읽도록, 강하게, 추천한다.
지시적인(즉 함수형) 생각의 힘을 보게 될 것이고, 깔끔하고 간결한 해답을 어떻게 사용할지 보게 될 것이다.</p>
<h2>future로 입문</h2>
<p>파일 읽기, 네트워크 요청, DOM 이벤트, 이런 함수들의 공통점은 뭘까?</p>
<p>이 함수들은 <em>즉시</em> 완료되지 않는 것들이다. 즉, (보통 함수들을 다루는 식으로는) 현재 프로그램
흐름에서 저 함수들이 완료될 때까지 기다릴 수 없다는 뜻이다. 그래서 _future_를 설명할 것이다.</p>
<p>그래서 특별한 반환 타입, 나중에 결과를 만들어준다고 명시하는 <code>Future</code>를 만들어보자. 요점은 다른
함수들로 넘길 수 있는 1등급 클래스 값을 사용하는 것이다.</p>
<p>Future는 무슨 의미일까? 특정 시간(0이 될 수도 있다) 후에 발생할 것이라고 명시해놓은 값이다.
그 시간은 우리가 x초 후라고 말하는 것처럼 명시적인 시간이 될 수도 있지만, Future 2개가 완료된 후
혹은 Future 하나가 완료된 뒤 다른 Future 완료될 때처럼 상대적인 개념일 수도 있다.</p>
<p>여기서 중요한 점은: <strong>Future의 결과는 항상 불변값이다.</strong></p>
<p>즉, 완료 값을 어떤 방법으로든 변경할 수 없다. 이 제약으로 구현 뿐만 아니라 의미론에 대한 추론도
간단해진다.</p>
<p>Future는 일회용의 간단한 상태머신처럼 구현될 수 있다. 이 머신은 <em>대기</em> 로 시작했다가 <em>완료</em> 가 된
후에 멈춘다. 한번 완료되면 계속 완료상태에 고정된다.</p>
<p>내부적으로 <code>Future</code>는 콜백에 여전히 의존하고 있지만, 그 콜백들이 컨트롤 흐름 매커니즘을 방해하지는
않는다. 대신 올바른 목적으로만 사용된다, 이벤트 알림.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Future</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 대기중인 구독들을 저장하는 리스트</span></span><br><span class="line">  <span class="keyword">this</span>.slots = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 완료를 알린다</span></span><br><span class="line">Future.prototype.ready = <span class="function"><span class="keyword">function</span>(<span class="params">slot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.completed) slot(<span class="keyword">this</span>.value);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">this</span>.slots.push(slot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 간단한 로그 유틸리티</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logF</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  f.ready( v =&gt; <span class="built_in">console</span>.log(v) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future를 완료시키는 외부 인터페이스로 메소드가 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.complete = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 불변성 보장</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.completed)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"이미 완료된 Future는 완료시킬 수 없다."</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.value = val;</span><br><span class="line">  <span class="keyword">this</span>.completed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 구독들에게 알림</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, len=<span class="keyword">this</span>.slots.length; i&lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>.slots[i](val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 모두 실행되면 이제 필요없다.</span></span><br><span class="line">  <span class="keyword">this</span>.slots = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future의 가장 간단한 예제로 어떤 값으로 <em>즉시</em> 완료시켜보자. 그 역할을 <code>unit</code>이란 메소드를
만들어보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unit: Value -&gt; Future&lt;Value&gt;</span></span><br><span class="line">Future.unit = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fut = <span class="keyword">new</span> Future();</span><br><span class="line">  fut.complete(val);</span><br><span class="line">  <span class="keyword">return</span> fut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logF( Future.unit(<span class="string">'hi now'</span>) );</span><br></pre></td></tr></table></figure>
<p>코드에 대해 간단히 설명하기 위해 <em>타입 표기(type annotation)</em> 를 사용했다.</p>
<p><code>unit: Value -&gt; Future&lt;Value&gt;</code>를 풀어보면 1- <code>unit</code>은 함수고, 2- 제네릭 타입 <code>Value</code>를
입력으로 받으며, 3- 제너릭 타입을 가진 <code>Future</code> 인스턴스를 리턴한다. 여기서 타입 정보는 중요하지
않으므로 <code>Value</code>라는 제너릭은 신경쓰지 않아도 된다.</p>
<p>다음 예제는 특정 시간이 지나고 완료되는 값이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delay: (Value, Number) -&gt; Future&lt;Value&gt;</span></span><br><span class="line">Future.delay = <span class="function"><span class="keyword">function</span>(<span class="params">v, millis</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">new</span> Future();</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    f.complete(v);</span><br><span class="line">  &#125;, millis);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logF( Future.delay(<span class="string">'안녕, 이건 5초 걸린다'</span>, <span class="number">5000</span>) );</span><br></pre></td></tr></table></figure>
<p><code>delay</code>의 결과는 주어진 값만큼의 시간이 지난 뒤에 완료되는 Future다.</p>
<p>readFile 예제로 돌아가서, 이제 CPS 함수 대신에 Future를 리턴하는 함수를 사용할 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// readFileF: (String, Object) -&gt; Future&lt;String&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFileF</span>(<span class="params">file, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">new</span> Future();</span><br><span class="line">  fs.readFile(file, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 에러는 잠시 후에 다루겠다</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    f.complete(data);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logF( readFileF(<span class="string">'test.txt'</span>, &#123;encoding: <span class="string">'utf8'</span>&#125;) );</span><br></pre></td></tr></table></figure>
<p><code>readFileF</code>의 결과는 인자로 받은 파일 이름의 내용을 잡고 있는 Future가 된다.</p>
<h2>Future 다루기: 첫번째 게스트</h2>
<p><code>Future</code>를 결과적으로 함수의 결과를 잡고 있는 마법 상자처럼 생각할 수도 있다.</p>
<p>뭔가 쓸모있는 것을 하려면 Future 타입에서 쓸모있는 연산들을 제공해야한다. 아니면 그냥 쓸모없는
<code>undefined</code>만 만들어낼 뿐이다. (?)</p>
<p>그러면 어떤 연산을 Future에서 제공해야할까?</p>
<p>Future 상자에서 잡고 있는 값에 어떤 연산을 하고 싶을 때 (function map을 줄인)<code>fmap</code>을 호출할
것이다.</p>
<p><code>fmap</code>의 예제를 보자. 여기서 Future는 텍스트 파일의 내용을 잡고 있고, 이 내용의 길이를 계산하려고
한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textF = readFileF(<span class="string">'test.txt'</span>, &#123;encoding: <span class="string">'utf8'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmap: (Future&lt;String, (String -&gt; Number)&gt; -&gt; Future&lt;Number&gt;)</span></span><br><span class="line"><span class="keyword">var</span> lengthF = textF.fmap( text =&gt; text.length );</span><br><span class="line">logF( lengthF );</span><br></pre></td></tr></table></figure>
<p><code>lengthF</code>의 뜻은 인자로 받은 Future가 잡고 있는 파일 내용의 길이를 잡고 있는 Future다.</p>
<p>일반화를 해보자면, <code>fmap</code>은 인자를 둘 받는데, 하나는 값을 잡고 있는 Future고 하나는 일반값을
다루는 매핑 함수다. 입력으로 받은 Future의 결과물에 매핑 함수를 적용한 결과를 잡고 이는 Future가
결과로 나온다. 받은 Future와 결과 Future는 둘 다 동시에 완료된다.</p>
<p>정확하진 않지만, 이렇게 표현할 수 있다</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmap( Future&lt;value&gt;, func ) = Future&lt; func(value) &gt;</span><br></pre></td></tr></table></figure>
<p><code>fmap</code>은 몇줄만으로 구현할 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.fmap = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fut = <span class="keyword">new</span> Future();</span><br><span class="line">  <span class="keyword">this</span>.ready(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    fut.complete( fn(val) );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> fut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>현재 Future가 완료되었을 때 결과로 나온 Future도 완료된다. 그 때 매핑 함수를 적용시킨다.</p>
<p>위의 예제에서는, 파일 내용을 잡고 있는 Future를 내용 길이를 잡고 있는 다른 Future로 변이시켰다.</p>
<p>어디서 들어본 말 같지 않은가? 잘 알고 있는 자바스크립트 Array의 <code>map</code> 메소드와 꽤 비슷하다.
실제로 정확히 같은 개념이다.</p>
<ul>
<li>Array  타입은 여러 값들을 잡고 있는 박스다</li>
<li>Future 타입은 완료될 값을 잡고 있는 박스다</li>
<li>Array.map(...) 은 Array 박스 안의 값들을 변이시켜서, 변이된 값들을 잡고 있는 다른 Array 박스를 돌려준다</li>
<li>Future.fmap(...)은 Future 박스 안의 값을 변이시켜서, 변이된 값을 잡고 있는 다른 Future 박스를 돌려준다</li>
</ul>
<p>Array와 Future 타입 둘 모두 포함되는 <strong>Functor</strong>라는 첫번째 게스트가 등장했다. 일반 함수를 하나
받아서 안에 무엇을 가지고 있든 그것이 변이된 결과를 표현하는 다른 인스턴스를 만들어내는 타입이다.</p>
<ul>
<li>다른 타입을 감싸는 컨텍스트처럼 작동할 수 있는 타입이고</li>
<li>내부에 있는 것을 일반 함수에 적용시킬 수 있다면</li>
</ul>
<p>Array와 Future가 아니더라도 그게 무엇이든간에 그 타입을 <strong>Functor</strong>라고 부를 수 있다.</p>
<p>이제 Future를 다른 Future로 매핑할 수 있다. 이제 일반값을 다루듯이 Future를 직접적으로 다루는
함수를 만들 수 있다는 뜻이다. <code>textF.fmap( c =&gt; c.length )</code>처럼 호출하는 대신에 Future를
직접 다루는 <code>lengthF</code>라는 특별한 종류의 함수를 만들 수도 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lengthF: Future&lt;String&gt; -&gt; Future&lt;Number&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lengthF</span>(<span class="params">strF</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strF.fmap( s =&gt; s.length )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>파일 길이를 읽는 예제를 흔히 보던 방법처럼 다시 작성할 수 있게 되었다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nbCharsF = lengthF( readFileF(<span class="string">'...'</span>) )</span><br></pre></td></tr></table></figure>
<p><code>lengthF</code>를 <em>lift된</em> 함수라고 부른다. Functor같은 _박스 타입_을 다루는 함수를 <strong>lift</strong>한다는
것은 일반값을 다루는 함수를 박스 타입을 다루는 함수로 만든다는 뜻이다. 여기에서는 문자열을 다루는 함수
<code>length(String)</code>를 lift해서 Future를 다루는 함수<code>lengthF( Future&lt;String&gt; )</code>로 lift했다.</p>
<p>일반화된 <code>lift1</code>(인자를 하나만 받아서 lift하는 함수)를 정의해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future.lift1 = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fut =&gt; fut.fmap(fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>비동기 실행을 일반 함수 실행처럼 만들어주는 간단한 추상 함수다. 위에서 <code>lengthF( readFileF('...') )</code>는
<code>readFileF</code>와 <code>lengthF</code>를 조합해서 비동기 연산을 현재의 흐름을 떠나지 않고 실행할 수 있다.</p>
<h2>인자를 여러개 받는 함수는 어떻게? (두번째 게스트?)</h2>
<p>질문에 대답하기 전에 잠시 기초지식에 대해 생각해보자: Future 박스가 잡을 수 있는 타입에는 뭐가
있을까? Future는 모든 타입에 대해 같은 의미를 가질까?</p>
<p><code>Future&lt;String&gt;</code>의 뜻은 명확하다: 시간이 지난 뒤에 문자열 타입의 값이 발생한다는 뜻이다. 다른
타입들에 이 의미를 확장할 수 있을까? 숫자, 객체, 배열? 그럴듯... 그럼 Future 자체에 대해서는
어떨까? <code>Future&lt;Future&gt;</code>는 무슨 뜻일까? 그러니까 Future의 Future는?</p>
<p>보고 바로 이해할 수 있도록, 디렉토리를 보고 첫번째 파일의 내용을 읽는 간단한 예제를 만들어보자
(간단히 생각하기 위해 내부에 다른 디렉토리가 없다고 가정한다).</p>
<p>Node.js에서는 비동기 함수 <code>fs.readdir</code>을 통해 디렉토리 속 파일들 이름의 배열을 가져올 수 있다.
먼저 이걸 Future식 함수로 만들어보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readDirF: String -&gt; Future&lt; Array&lt;String&gt; &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readDirF</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">new</span> Future();</span><br><span class="line">  fs.readdir(path, (err, files) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 기다리면 곧 실행된다</span></span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    f.complete(files);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readDirF</code>는 디렉토리 내 파일 이름들의 배열을 기다리는 Future를 뜻한다.</p>
<p>위에서 말한걸 구현하려면 필요한 나머지는</p>
<ol>
<li>Future가 잡고 있는 파일 이름들의 배열을 기다린다.</li>
<li>첫번째 파일명을 가져온다.</li>
</ol>
<p>여기서 <code>fmap</code>을 사용할 수 있을까? Node에서 이걸 실행해보자</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resultF = readDirF(<span class="string">"testdir"</span>).fmap( files =&gt; readFileF( files[<span class="number">0</span>]) )</span><br><span class="line">logF( resultF )</span><br></pre></td></tr></table></figure>
<p>기다리면... 아차</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; slots: [] &#125;</span><br></pre></td></tr></table></figure>
<p>확실히 뭔가 잘못됐다. 콘솔에서 파일 내용이 나오는게 아니라 Future 인스턴스 객체의 내용이 나왔다.</p>
<p>왜냐면 <code>fmap</code>은 매핑 함수의 결과가 무엇이든 받아서 그걸 Future로 잡아 돌려주기 때문이다. 위에서의
매핑 함수는 또다른 Future(<code>readFileF</code>의 결과)를 <code>fmap</code>은 그 Future를 잡는 Future를 만들어
<code>resultF</code>에 보내기만 한다.</p>
<p>하지만 Future는 잡고 있는 Future와 함께 끝나는지 않으므로, <em>속에 있는</em> Future가 완료될 때까지
계속 기다릴 뿐이다.</p>
<p>그래서 이럴 때 필요한 함수를 만들어보자. Future를 리턴하고 끝내는 대신에 속에 있는 Future가 끝날
때까지 기다리는 함수다.</p>
<p>(이중 Future)Future<future>를 그냥 Future로 만들어주는 <code>flatten</code>를 만들어보자.</future></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flatten: Future&lt; Future&lt;Value&gt; &gt; -&gt; Future&lt;Value&gt;</span></span><br><span class="line">Future.prototype.flatten = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fut = <span class="keyword">new</span> Future();</span><br><span class="line">  <span class="keyword">this</span>.ready(<span class="function"><span class="keyword">function</span>(<span class="params">fut2</span>) </span>&#123;</span><br><span class="line">    fut2.ready( <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">      fut.complete(val);</span><br><span class="line">    &#125; );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> fut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이렇게 하면 원하는 결과를 얻을 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = readDirF(<span class="string">"testdir"</span>)</span><br><span class="line">              .fmap( files =&gt; readFileF(files[<span class="number">0</span>], &#123;encoding: <span class="string">'utf8'</span>&#125;) )</span><br><span class="line">logF( result.flatten() )</span><br></pre></td></tr></table></figure>
<p><code>fmap</code>과 <code>flatten</code>을 따로 부르는 대신에 한번에 부를 수 있게 합쳐보자: 매핑 함수에서 나온 2중
Future를 압축(flatten)하는 두가지 일을 한다. 하는 일 그대로 <code>flatMap</code>이라고 하자
(좀 이상한건 나도 안다).</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.flatMap = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.fmap(fn).flatten();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>개념상으로는 위에서 독립적인 두 연산을 _이어서_하는 것인데, <code>readDirF</code>에서 나오는 파일 이름의
배열을 <code>readFileF</code>에 넘겨준다.</p>
<p>여기에서 두번째 게스트가 등장하는데, Future를 Functor라고 부를 수 있는 것처럼 <strong>Monad</strong>라고 부를
수도 있다. 순서대로 연산할 수 있는 방법에 대한 개념이다. 위에서 <code>flatMap</code>에서처럼, 이전 단계에서의
결과를 다음 단계로 넘겨서 여러 함수를 연이어 연산할 수 있다.</p>
<p>Functor처럼 Monad도 많은 사용법이 있는데, 기술적으로 모든 모나드는 다음을 만족한다.</p>
<ul>
<li>일반값을 <em>Monad식(Monoadic) 값</em> 으로 lift하는 방법: 예를 들어, <code>Future.unit</code>은 일반값을 Future로 만든다.</li>
<li>연이은 연산 2개를 이어서 실행하는 방법: Monad는 연산을 이어서 실행하게 해주는 방법이 포함된다. 위에서 <code>flatMap</code>은 그냥 Future 하나만 만들고 다음으로 넘어가는게 아니라, 앞의 Future가 끝날 때까지 기다렸다가 넘어가는 방법이 들어있다.</li>
</ul>
<p>위에서 2개의 다른 연산(<code>fmap</code>과 <code>flatten</code>)으로 두번째 인터페이스(<code>flatMap</code>)를 만들 수 있다는
것을 확인했다. fmap 함수를 정의하는 Functor라면 이중 구조를 단순화시켜서 합치는(flatten) 연산이
필요해진다.</p>
<p>이제 처음의 질문으로 돌아가보자, Future들 여러개를 받는 함수를 어떻게 lift할 수 있을까?</p>
<p>다시 파일 예제로 돌아가서, 디렉토리의 모든 파일 내용을 합치려면 이런 코드가 될 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concatF: (Future&lt;String, ...) -&gt; Future&lt;String&gt;</span></span><br><span class="line"><span class="keyword">var</span> resultF = concatF( text1F, text2F, ...)</span><br></pre></td></tr></table></figure>
<p>이건 무슨 뜻일까? 입력받은 Future들이 잡고 있는 각 문자열들을 합친 것을 다시 잡고 있는 Future를
만들어준다. <code>concatF</code>는 입력받은 모든 Future들이 순서대로 처리되도록 기다려야하므로 결과로 나온
Future는 입력받은 모든 Future가 완료될 때 완료된다.</p>
<p>인자 2개를 받는 경우부터 시작해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn: (Value, Value) -&gt; Value</span></span><br><span class="line"><span class="comment">// lift2: ( (Value, Value) -&gt; Value ) -&gt; ( (Future, Future) -&gt; Future )</span></span><br><span class="line">Future.lift2 = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (fut1, fut2) =&gt; &#123;</span><br><span class="line">    fut1.flatMap( value1 =&gt; </span><br><span class="line">      fut2.flatMap( value2 =&gt;</span><br><span class="line">        Future.unit( fn(value1, value2) );</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>보이는 것과는 별개로 코드의 로직은 꽤 간단하다. 한줄씩 읽어보자면:</p>
<ul>
<li><code>Future.lift2</code>는 &quot;일반값 2개를 다루는 함수&quot;를 받아서 &quot;Future 2개를 다루는 함수&quot;를 리턴한다.</li>
<li>리턴된 (lift된) 함수가 실제로 하는 일은
<ul>
<li>(중첩되어 실행되는) 2개의 연산을 순서대로 <code>flatMap</code>에 넣고</li>
<li>첫번째 연산은 그 자체로 하는게 없지만 <code>value1</code>을 바인딩해서 스코프에 묶어두는 역할을 하고</li>
<li>두번째로 중첩된 연산은 <code>value1</code>과 <code>value2</code>를 <code>fn</code>에 넘긴다.</li>
<li><code>fn</code>은 일반값을 리턴하는데 <code>flatMap</code>은 받은 함수가 Future를 리턴해야하므로 <code>Future.unit</code>을 통해 일반값을 Future로 lift한다.</li>
</ul>
</li>
</ul>
<p>이게 트릭이다: 모든 Future에서 순차적으로 <code>flatMap</code>을 실행해서 모두 끝나길 기다린 다음에 모든
완료값이 한 스코프에 모였을 때 함수를 실행한다.</p>
<p><code>readDir</code> 내부에서 <code>readFile</code>를 실행하는 것처럼 순차 연산으로 설명되는 <em>Monadic</em> 값과는 다르게
여러 인자를 한번에 lift하도록 마지막에 <code>Future.unit</code>를 사용했다.</p>
<p>파일 2개의 내용을 합치기 위한 예제다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> concat2 = Future.lift2( (str1, str2) =&gt; str1+<span class="string">' '</span>+str2 );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text1 = readFileF(<span class="string">'test1.txt'</span>, &#123;encoding: <span class="string">'utf8'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> text2 = readFileF(<span class="string">'test2.txt'</span>, &#123;encoding: <span class="string">'utf8'</span>&#125;);</span><br><span class="line"></span><br><span class="line">logF( concat2(text1, text2) );</span><br></pre></td></tr></table></figure>
<p>두번째 Future <code>text2</code>가 첫번째의 <code>text1</code>보다 먼저 끝나더라도 <code>text1</code>을 기다리게 되고,
<code>text1</code>이 끝나면 <code>text2</code>는 이미 끝났으므로 바로 함수를 실행한다.</p>
<p>여러 인자를 받는 함수는, 입력들이 언제 끝나는지나 의존성과는 관련없다는 것을 알 수 있다.
이걸 정리하면 다음과 같다.</p>
<ul>
<li><code>fmap</code>이 하나의 연산을 실행하고</li>
<li><code>flatMap</code>은 순차 연산을 실행하지만</li>
<li>여러 인자를 lift하는 함수는 <em>병렬</em> 실행이다.</li>
</ul>
<p>위에서 봤듯이, Future들을 한번에 실행하고 연산이 진행되기 전에 이미 그 결과를 기다리고 있다.</p>
<p><code>lift2</code>의 패턴을 <code>lift3</code>이나 <code>lift4</code>로 쉽게 확장할 수 있지만, 인자의 갯수와 관계없이 위에서
나온 중첩과 스코프를 통해 일반화를 구현해볼 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future.lift = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> futArgs = toArray(<span class="built_in">arguments</span>), <span class="comment">// Future 인자들</span></span><br><span class="line">        ctx = <span class="keyword">this</span>; <span class="comment">// 컨텍스트(`this`)를 저장</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bindArg(<span class="number">0</span>, []);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bindArg</span>(<span class="params">index, valArgs</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 현재 Future 인자를 기다린다</span></span><br><span class="line">      <span class="keyword">return</span> futArgs[index].flatMap(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        valArgs = valArgs.concat(val); <span class="comment">// 완료값들을 모은다.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (idnex &lt; futArgs.length - <span class="number">1</span>) ? <span class="comment">// 아직 마지막 Future 인자가 아니라면</span></span><br><span class="line">          bindArg(index+<span class="number">1</span>, valArgs) : <span class="comment">// 다음 인자를 flatMap에 넘기고 기다린다</span></span><br><span class="line">          Future.unit( fn.apply(ctx, valArgs) ); <span class="comment">// 끝까지 오면 모은 완료값들을 함수에 넘긴다</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lift</code>에서는 <code>lift2</code>의 패턴을 재활용했다. 인자가 몇개 들어올지 정확히 모르니 재귀를 통해 전체를
순회(iterate)하고, 완료를 기다렸다가 결과를 계속 넘겨서 모은다.(<code>index</code>번째의 Future를
기다렸다가 완료값을 저장하고, 모든 입력이 완료될 때까지 다음 Future 입력에 이 연산을 반복한다.)
마지막 Future까지 오면 함수를 실행하고 결과를 lift해서 리턴한다.</p>
<p>노트: 'Applicative Functor'라는 자료구조를 통해 n개 인자를 lift하도록 구현할 수 있지만,
그러려면 람다나 커리에 대한 설명을 해야하므로 오늘은 일단 생략하자.</p>
<h2>에러 처리</h2>
<p>위에서 <code>fs.readFile</code>의 에러값을 어떻게 뒀는지 다시 확인해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFileF</span>(<span class="params">file, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">new</span> Future();</span><br><span class="line">  fs.readFile(file, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>실제로 작동하지 않는 코드다. 프로그램 흐름에서 떨어져서 실행중이므로 발생하는 에러를 잡을 방법이 없다.
위의 상황에서 에러는 상위로 전파되며 잡는 핸들러가 없어서 Node.js 전체 프로그램을 중단시킨다.</p>
<p>에러를 잡아 흐름을 고치려고 한다거나 의미있는 메시지를 사용자에게 전달하는게 필요할 수도 있다.</p>
<p>가능한 방법으로는 <code>Future</code>에 <em>실패</em> 의 개념을 붙여서 의미를 확장하는 것이 있다. 아직까지는 Future의
결과에 어떤 의미를 붙이지는 않았지만, 가능한 2가지 결과(완료 혹은 실패)로 Future를 생각해볼 수도 있다.
실패에 대한 경우가 포함되었는지 확인해보자.</p>
<p>먼저, 완료를 알리는 <code>ready</code> 메소드가 있으니 실패를 알리는 메소드를 정의해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Future</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.slots = [];</span><br><span class="line">  <span class="keyword">this</span>.failslots = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future.prototype.failed = <span class="function"><span class="keyword">function</span>(<span class="params">slot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.hasFailed) slot(<span class="keyword">this</span>.error);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">this</span>.failslots.push(slot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future가 실패할 때의 메소드도 정의해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.fail = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.completed || <span class="keyword">this</span>.hasFailed)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"이미 끝난 Future를 실패할 수는 없다!"</span></span><br><span class="line">  <span class="keyword">this</span>.hasFailed = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.error = err;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, len=<span class="keyword">this</span>.failslots.length ; i&lt;len ; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failslots[i](err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 <code>fmap</code>를 다시 생각해보자.</p>
<p><code>readFileF(...).fmap( s =&gt; s.length)</code> 예제에서 파일이 없을 때에 대한 처리가 없다.
제대로 읽었을 때에 대해서만 변환하기 때문에 아닐 때는 에러와 함께 실패할 것이다. 혹시 변환 중 실패할
경우에도 실패해야한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.fmap = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fut = <span class="keyword">new</span> Future();</span><br><span class="line">  <span class="keyword">this</span>.ready( val =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>        &#123; fut.complete( fn(val) ); &#125;</span><br><span class="line">    <span class="keyword">catch</span>(err) &#123; fut.fail(err); &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.failed( err =&gt; fut.fail(err) );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>flatten</code>은 약간 복잡하다. 안쪽과 바깥쪽의 Future 2개가 있고, 각각 완료될 수도 실패할 수도 있다.
그래서 4가지(2x2) 경우를 다뤄야한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.flatten = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fut = <span class="keyword">new</span> Future();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1- 밖깥 실패 안쪽 실패 =&gt; 결과 실패</span></span><br><span class="line">  <span class="comment">// 2- 바깥 실패 안쪽 완료 =&gt; 결과 실패</span></span><br><span class="line">  <span class="keyword">this</span>.failed( _ =&gt; fut.fail(err) );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3- 바깥 완료 안쪽 실패 =&gt; 결과 실패</span></span><br><span class="line">  <span class="keyword">this</span>.ready( fut2 =&gt;</span><br><span class="line">    fut2.failed( err =&gt; fut.fail(err) );</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4- 바깥 완료 안쪽 완료 =&gt; 결과 완료</span></span><br><span class="line">  <span class="keyword">this</span>.ready( fut2 =&gt;</span><br><span class="line">    fut2.ready( val =&gt; fut.complete(val) );</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>flatten</code>에서 안쪽과 바깥쪽 모두 완료되었을 때만 결과가 완료된다.</p>
<p><code>flatMap</code>과 <code>lift</code>는 수정할 필요가 없다. 이미 <code>fmap</code>과 <code>flatten</code>의 의미를 가져오는 것이기
때문에 자동으로 에러에 대한 의미가 추가된다.</p>
<p>자, 이제 실패한 Future들은 연산에서 제외하게 만들었다. 그럼 실패한 Future들을 어떻게 다뤄야할까?</p>
<p>Future 에러를 <em>잡아서</em> 고치면 된다. 어떻게? 실패한 Future를 완료값으로 변이시켜서 원래의 연산에
포함시키면된다.</p>
<p><code>fmap</code>과 비슷하지만 좌우반전같은 <code>fmapError</code> 함수를 만들 것이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.fmapError = funciton(fn) &#123;</span><br><span class="line">  <span class="keyword">var</span> fut = <span class="keyword">new</span> Future();</span><br><span class="line">  <span class="keyword">this</span>.ready( val =&gt; fut.complete(val) );</span><br><span class="line">  <span class="keyword">this</span>.failed( err =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>         &#123; fut.complete( fn(err) ); &#125;</span><br><span class="line">    <span class="keyword">catch</span>(err1) &#123; fut.fail(err1); &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> fut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fmapError</code>는 <code>catch</code>문의 비동기 버전처럼 작동하며, 정상적으로 완료되면 그냥 값을 넘기고 에러가
발생했을 때는 매핑 함수에 적용시켜서 완료값으로 넘긴다.</p>
<p>간단히 예제를 만들어보자</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readFileF(<span class="string">'unknown file'</span>).fmapError( err =&gt; <span class="string">'alternate content'</span>)</span><br></pre></td></tr></table></figure>
<p>그럼 에러를 Monad식으로 파이프라인처럼 다음 연산으로 넘기려면?</p>
<p><code>flatMap</code>의 좌우반전같은 <code>flatMapError</code>를 만들어보자</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.flatMapError = funciton( fn )&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.fmapError(fn).flatten();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>예를 들어서 어떤 주소(URL)에서 내용을 가져오려고 할 때 요청이 실패한다면 다른 주소에서 가져오도록
시도를 하려고 하는데, <code>flatMapError</code>을 사용해서 앞의 실패를 잡아서 다른 요청을 만들 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resultF = requestF(<span class="string">'/url1'</span>).flatMapError( err =&gt; requestF(<span class="string">'/url2'</span>) )</span><br></pre></td></tr></table></figure>
<p><code>resultF</code>는 첫번째 요청이 성공할 때 <code>'url1'</code>의 내용을 잡고 있고, 실패할 때는 <code>'url2'</code>를
요청해서 그 결과를 잡고 있다는 뜻이다.</p>
<h2>부수효과</h2>
<p>합성해서 연산할 수 있는 방법에 대해 필요한 것들을 모두 다뤄보았다. 지금까지 다뤘던 함수들을 통해서
Future를 동기 연산을 할 때처럼 일반값으로 넘겨서 비동기 처리를 하게 해봈다.</p>
<p>하지만 연산들은 끝까지 도달해야 결과가 나온다. 부수효과가 필요한 연산들을 다뤄 볼 시간이다. UI를
업데이트한다거나 콘솔에 로그를 찍는다거나 데이터베이스에 저장을 한다거나.</p>
<p><code>ready</code>와 <code>failed</code> 이벤트를 사용할 수도 있지만 좋은 방법은 아니라고 생각한다.</p>
<p>실제 어플리케이션에서 한 Future가 여러 자식 Future들을 가지고 그 Future들은 또 자식 Future들을
갖게 되는 트리같은 구조가 된다. Future하나가 완료돌 때 매핑된 Future들이 연쇄적으로 완료된다.</p>
<p>Future의 <code>ready</code>알림을 통해서 부수효과를 실행하려고 한다면 트리 내부에 있는 Future들 전체에
영향을 끼치게 된다. 의미적으로나 구현상으로나 업데이트가 끝날 때까지 부수효과 연산을 미뤄두는 것이 좋다.
예를 들어 DOM을 업데이트할 때는 <code>requestAnimationFrame</code>같은 스케쥴러에 맡기는게 더 좋을 수도 있다.</p>
<p>위에서 말한 이유로 <code>do</code>라는 메소드를 하나 만들텐데 부수효과 연산을 명시하는 것이다. <code>fmap</code>처럼
부수효과 함수를 받겠지만, 내부의 알림들(<code>ready</code>와 <code>failed</code>)이 완료될 때까지 지연될 것이다.</p>
<p>예를 들어</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestF(<span class="string">'/url'</span>).do( val =&gt; <span class="comment">/* update ... */</span> )</span><br></pre></td></tr></table></figure>
<p>이번에도 <em><code>do</code>의 의미와 리턴값이 무엇인지</em> 생각해보자.</p>
<p>변이없이 그냥 Future를 리턴한다면 <code>future.fmap( Id )</code>(여기에서 <code>Id</code>는 <code>x =&gt; x</code> 같은 항등함수)
와 같은 형태이다. <code>fmap</code>과 다른 점은, 먼저 <code>do</code>에서 부수효과가 발생한다는 점이고 두번째는 다른
컨텍스트에서 실행된다는 점이다.(<code>fmap</code>은 즉시, <code>do</code>는 나중에). 가장 다른건 _의미_다.</p>
<blockquote>
<p>정정: 2015년 4월 6일. <code>Action</code>이라는 새로운 타입을 통해 <code>do</code>를 적용했는데, 굳이 Monad(Future)
안에 다른 Monad(Action)을 넣어 복잡하게 만들 필요가 없었다. 서버에 데이터를 넘기거나 응답을
기다리는 등의 상황에서 리턴값이 필요할 수도 있는데, 다음 글에 이걸 개발해 볼 수도 있다.</p>
</blockquote>
<p>빠르게 대충 구현해보자.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Future.prototype.do = funciton(action) &#123;</span><br><span class="line">  <span class="keyword">var</span> fut = <span class="keyword">new</span> Future();</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.completed) &#123;</span><br><span class="line">    action(<span class="keyword">this</span>.value);</span><br><span class="line">    fut.complete(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.actions.push( val =&gt; &#123; </span><br><span class="line">      action(val);</span><br><span class="line">      fut.complete(val);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future.prototype.complete = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line">  setTimeout( () =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, len=me.actions.length ; i&lt;len; i++)</span><br><span class="line">      me.actions[i](val);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>덧붙여서, 비동기실행을 제대로 구현하려면 process.nextTick이나 MessageChannel 등을 사용해야
하지만 여기서는 간단히 구현하고 넘어가자. 비슷하게, 부수효과의 실패에 대응해 <code>doError</code>도 만들어야
하는데, <code>do</code>와 비슷하므로 각자 알아서 구현해보자. (<a href="https://gist.github.com/yelouafi/40aeb2a70a368acb6e45" target="_blank" rel="external">Gist에 코드 전체가 있다</a>)</p>
<hr>
<p>역주 1: Promise와의 비교는 Future/Functor/Monad 개념을 이해하는데 관계없다고 생각해서 생략했다.</p>
<p>역주 2: <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="external">그림으로 설명하는 Functor, Applicative, Monad</a>(<a href="http://netpyoung.github.io/external/functors_applicatives_and_monads_in_pictures/" target="_blank" rel="external">번역</a>)과 함께 읽으면 이해하는데 도움이 될 것이다.</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/blog/tags/functor/" class="post__tag__link">functor</a></li><li class="post__tag__item"><a href="/blog/tags/monad/" class="post__tag__link">monad</a></li><li class="post__tag__item"><a href="/blog/tags/translation/" class="post__tag__link">translation</a></li></ul><a href="https://github.com/seoh/blog/tree/master/source/_posts/callback-to-future-functor-applicative-monad.md" class="post__foot-link u-fr">Pull Request</a><a href="https://github.com/seoh/blog/issues/new" class="post__foot-link u-fr">Tell me</a></footer></article><article class="post"><header class="post__head"><time datetime="2015-01-18T13:21:37.000Z" class="post__time">18th Jan, 2015</time><h1 class="post__title"><a href="/blog/2015/01/18/transitioning-to-scala/">번역, 스칼라로 전환</a></h1></header><div class="post__main echo"><blockquote>
<h3>Translation of &quot;<a href="https://medium.com/p/d1818f25b2b7" target="_blank" rel="external">Transitioning to Scala</a>&quot; into Korean, under the same license as the original.</h3>
</blockquote>
<p>2011년 말부터 2014년 초까지 전자상거래 솔루션 전문 에이전시, <a href="https://www.nurun.com/en/careers/toronto/" target="_blank" rel="external">Nurun Toronto</a>에서 리드개발자로 일했다. 자바와 스프링만으로 새로운 프로젝트들을 계속하다보니 대체제를 찾아야할 때라는걸 알게 되었다.</p>
<p>에이전시에서의 업무를 장기적인 관점에서 생각해봤다. &quot;자바가 구리다&quot;를 이해하지 못하는 고객들 때문에 마감에 시달렸다. 2004년도에 어플리케이션을 만들던 툴과 테크닉들은 2014년에는 별 도움이 되질 않았다. 2004년에는 코드 한줄을 테스트하기 위해 서버를 재시작하는게 당연했다 - 웹스피어는 재시작할 때 정체불명의 1200줄 XML 설정파일을 읽어오는데, 평균 걸리는 시간이 커피 한잔 마시고 오기 딱 좋은 120초 정도다. 요새는 이렇게 하면 에이전시나 개발자나 망한다.</p>
<p>우리가 만드는 어플리케이션들은 단순히 데이터베이스의 뷰어가 아니라, 매일매일 똥을 치워주는 소중한 도구다.</p>
<h3>1. 왜 타입세이프의 스택을?</h3>
<p>지난 프로젝트를 루비온레일즈로 진행해보고 뭘 싫은지를 알았다. 다른 동적 타입 언어도 인터프리트 언어도 상태기반 웹 프레임워크(stateful web framework)도 쓰기 싫었다. 자바 바이트코드로 컴파일되는 정적 타입 언어나 활발한 생태계를 가진 툴들, 그리고 확장성을 위한 무상태 웹 프레임워크가 더 괜찮았다. 또한 우리 고객사들은 믿을만한 회사를 통해 전문적인 기술지원을 받을 수 있어야 마음의 위안을 가졌다.</p>
<p>그래서 몇가지 선택지를 꼽아봤는데, 가장 먼저 타입세이프가 떠올랐다. 우리가 원하는 모든 것들이 있었다.</p>
<p>컨셉증명을 위해 초소형 전자상거래 사이트를 내부적으로 만들어서 스칼라의 단순함과 플레이의 개발 생산성에 대해서 시연했고 충분히 관심을 끌어서 결국 <a href="http://walmart.ca/" target="_blank" rel="external">월마트 캐나다</a>의 새로운 전자상거래 플랫폼의 토대가 되었다.</p>
<h3>왜 스칼라가 복잡하다고 느낄까?</h3>
<p>스칼라는 <em>유연하다</em>. 유연하다는 것은 단순하다는 것을 포기해야하는 일이지만, 다른 면으로 스칼라는 단순히 &quot;자바보다 나은&quot; 정도가 아니라 그보다 더 좋으며 매우 우아한 언어이다. 스칼라나 새로운 어떤 언어로의 전환이라는 큰 도전은 단지 기술적인 일만이 아니다. 능력있는 개발자라면 새로운 문법, 새로운 개념, 새로운 IDE를 배울 수 있다. 변화는 기술보다는 그 과정이나 문화같은 다른 면에서 어렵다.</p>
<blockquote>
<p>짧게 말해서, 모든 것은 사람에 달려있다.</p>
</blockquote>
<p>이 글의 뒷부분은 스칼라 프로그래밍 튜토리얼이 아니다. 이미 많은 글들이 있고, 고급 스칼라의 깊은 부분에 대한 최신 트릭을 가르칠 만큼 나는 인정받은 스칼라 개발자도 아니다. 이 뒤로는 스칼라로의 전환을 생각하고 있는 개발자들, 팀장 혹은 매니저들에게 전하는 조언들이다. 이 조언들은 기업용 스칼라 프로젝트를 이끌 때 개인적으로 한 경험을 토대로한 것들이다.</p>
<h3>스칼라로의 전환을 생각 중인 매니저와 개발자들에게 하는 조언</h3>
<figure>
<img src="/blog/images/transitioning-to-scala/1.jpg"><figcaption class="image-caption">스칼라, 커피 한잔보다 좋다!</figcaption>
</figure>
<h3>1. 언어의 기능들을 이해해라</h3>
<p>모든 스칼라 개발자, 팀장, 매니저는 마틴 오더스키의 <a href="http://www.scala-lang.org/old/node/8610" target="_blank" rel="external">스칼라 레벨 가이드</a>를 읽어야한다.</p>
<p>전업 스칼라 개발자로 경력 1년반이 지나고 엔터프라이즈 스칼라 프로젝트도 진행했지만, 마틴의 가이드에서 스칼라 개발자 등급 A2.5/L1.5라고 생각한다. A3/L3에 있는 테크닉들을 사용하지만, 웹 어플리케이션을 쭉 개발해오면서 대부분은 써본 적이 없다. 케이크 패턴을 써본 적도 없고, 고계도 타입(high-kinded type, 역주: <a href="http://twitter.github.io/scala_school/ko/advanced-types.html#higher" target="_blank" rel="external">스칼라 학교</a>에서는 <em>상류 타입</em>이라고 번역했는데, 하나의 Layer 위에 있다는 생각으로 고계高階를 생각해봤다)을 써본 적이 아직 없다. 그렇다고 나쁜 개발자도 아니고, <a href="http://ko.wikipedia.org/wiki/%EA%B0%80%EB%A9%B4%ED%98%84%EC%83%81" target="_blank" rel="external">가면현상</a>의 증상도 아니고, 단지 내 시간은 한정되어있고 가장 돈이 되는 것에 집중하려고 한다. 게다가 드럼도 치고 기타도 치고 일주일에 두번 댄스 레슨도 다니고 커피도 많이 마시고 데이트하러 나가야한다. 시간은 소중하니까.</p>
<p>Walmart.ca 프로젝트에서는 콤비네이터 파서와 폴드를 사용하지도 않고 레벨 가이드의 얇은 부분만을 썼다. &quot;얇은&quot; 스칼라로도 이전 플랫폼보다 훨씬 좋은 생산성을 보여줬다. 구현하는데 골치아픈 일도 없었다. 그렇게 짠 코드들은 이전보다 더 관리하기에도 좋고 생산성도 더 좋았다. 블랙 프라이데이나 박싱 데이(역주, 북미지역 등지에서 추수감사절 시즌/크리스마스 시즌에 대부분의 쇼핑몰들이 매년하는 대량할인 이벤트 기간들)에서의 확장도 완벽하게 돌아갔고, 많은 자바기반의 전자상거래 플랫폼은 하지 못했던 것들이다.</p>
<p>그래서 중요하지 않다는건가?</p>
<p>단순하게 스칼라를 쓴다는 것을 스칼라가 부족하다는 것으로 착각하지 마시길. A1과 A2 등급에서 익힐 수 있는 것들을 보자.</p>
<ul>
<li>간단한 클로저</li>
<li>map, filter 등의 콜렉션</li>
<li>패턴 매칭</li>
<li>trait 합성</li>
<li>재귀</li>
<li>XML 표현식</li>
</ul>
<p>(역주: 코멘트에서 XML 표현식은 <a href="http://www.swift.com/" target="_blank" rel="external">SWIFT</a>에서 사용중이라고 한다.)</p>
<p>자바에 몇개 더 추가한 것과 비슷하다. 서술하듯이 개발하고 소프트웨어를 관리하는 새로운 방법이다. A3에 있는 몇개도 익히기 꽤 쉽고 - Akka나 다른 병렬 처리 라이브러리들을 사용하기 위해 꽤나 중요한 것들인데 - 그에 비해 크게 어렵지 않고 수학 학위가 필요할 정도는 아니다.</p>
<ul>
<li>fold</li>
<li>stream, 혹은 지연평가 자료구조</li>
<li>actor</li>
<li>combinator parser</li>
</ul>
<p>이런 테크닉들을 익혔을 때의 좋은 부가효과는, 사용하는 <strong>모든</strong> 언어에서 더 좋은 개발자가 된다는 것이다. 나는 스칼라와 자바스크립트 모두에서 클로저나 다른 테크닉들을 익히는데 정말 도움이 됐고 더 좋은 자바스크립트 프로그래머가 되었다.</p>
<h3>2. 시간을 써라</h3>
<p>자바에서 건너온 많은 스칼라 개발자들은 바로 적응하고 싶어하지만 스칼라는 완전히 다른 언어다. 새로운걸 익힌다는 것은 연습을 필요로 한다. 스칼라도 예외는 아니다.</p>
<p>좋은 소식은 A2/L1 등급만으로도 충분히 스칼라 어플리케이션을 만들만한 자격이 있다는 것이다. 모든 스칼라 개발자가 고급 순수함수 자료구조, 타입 이론, 고계도 타입을 이해하고 있을 필요는 없다. 하지만 스칼라는 차세대 어플리케이션을 만드는 전문 개발자를 위한 프로그래밍언어라는 것이다. 그래서 배우고 체득하는데 많은 시간이 걸릴 것이다.</p>
<p>###3. 배우는걸 두려워말라</p>
<p>자바 개발자라면 다음과 같은 자료들을 통해 스칼라를 배우길 강력히 추천한다.</p>
<ul>
<li><a href="http://www.amazon.com/Scala-Impatient-Cay-S-Horstmann/dp/0321774094" target="_blank" rel="external">Scala for the Impatient</a>를 읽어라. 특히 <em>예제</em>가 필요한 성격급한 개발자들에게 좋은 시작점이다. (역주, 번역판 <a href="http://www.bjpublic.co.kr/skin12/product_list.php?boardT=v&amp;page_idx=9&amp;goods_data=aWR4PTk2JnN0YXJ0UGFnZT0zNiZsaXN0Tm89NjEmdGFibGU9cmVkX2dvb2RzJnBhZ2VfaWR4PTkmc2VhcmNoX2l0ZW09%7C%7C" target="_blank" rel="external">쉽게 배워서 빨리 써먹는 스칼라 프로그래밍</a>, 2013 비제이퍼블릭)</li>
<li>마틴 오더스키, 렉스 스푼, 빌 베너스의 <a href="http://www.amazon.com/Programming-Scala-Comprehensive-Step---Step/dp/0981531644" target="_blank" rel="external">Programming in Scala</a>를 읽어라. <em>Scala for the Impatient</em>보다 더 자세한 책이라 언어의 기능들에 대해 폭넓은 시야를 익히기에도 좋다. (역주, 번역판 <a href="http://www.acornpub.co.kr/book/programming-in-scala" target="_blank" rel="external">Programming in Scala</a>, 2014 에이콘)</li>
<li>가능하면 Coursera의 <a href="https://www.coursera.org/course/progfun" target="_blank" rel="external">Functional Programming Principles in Scala</a> 코스를 들어라. Coursera가 Scala로 만들어졌다.</li>
<li><a href="https://typesafe.com/activator" target="_blank" rel="external">Typesafe Activator</a> 템플릿들을 살펴봐라. 다른 언어들에 비해 온라인 문서나 학습자료가 부족하기도 하지만, 다른 사람 코드를 분석하는게 제일 좋은 방법이기도 하다. 특히 James Ward같은 능력있는 개발자들이 짠 코드라면.</li>
<li>가능하면 Coursera의 <a href="https://www.coursera.org/course/reactive" target="_blank" rel="external">Principles of Reactive Programming</a> 코스를 들어라. 스칼라와 대량 데이터 처리를 위한 Akka를 사용하려는 개발자들에게 좋은 자료다.</li>
<li>스칼라 모임에 참석하고 스칼라를 사용하는 실무자들이 어디에 쓰는지 배워라.</li>
<li><a href="http://www.amazon.com/Functional-Programming-Patterns-Scala-Clojure/dp/1937785475" target="_blank" rel="external">Functional Programming Patterns in Scala and Clojure</a>를 읽어라. 예전의 명령형 스타일 코드와 더 읽을만해진 함수형 스타일 코드를 비교해보고 더 함수형의 언어를 배우고 싶어졌다. 하스켈은 좀 과하고, 그래서 Clojure를 배우기 시작했다. 그리고나서 내 스칼라 코드는 더 간략해지고 더 의미있어졌다.</li>
</ul>
<h3>4. 온라인에서 읽는 것들은 적당히 감안해서</h3>
<p><a href="https://github.com/scalaz/scalaz" target="_blank" rel="external">Scalaz</a>를 만든 <a href="http://blog.tmorris.net/" target="_blank" rel="external">토니 모리스</a>처럼 다른 세계에서 온 똑똑한 개발자들이 많이 있다. 하스켈 세계나, 함수형 프로그래밍, 그리고 수학 분야.</p>
<p>토니는 다음과 같은 함수 선언에 반대를 한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span>[<span class="title">A</span>]:</span> List[A] =&gt; List[A]</span><br></pre></td></tr></table></figure>
<p>그리고 이런 선언을 더 선호한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> &lt;-:</span>[A, B](f: A =&gt; B): List[A] =&gt; List[B]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>다음에 &lt;-:라는 이름의 함수를 보면 이렇게 생각해라, &quot;으악, 읽기도 구리고 내가 뭘 하고 있는거야?&quot;, (아마 친근보다는 좀 강력한) 다른 툴은 없는지? 이거 타입은 뭐지? 대수적인 속성은 뭐지? 드러난 속성들이 또 뭐가 있지?</p>
<p><a href="http://blog.tmorris.net/posts/identifier-names/index.html" target="_blank" rel="external">Sticks, stones, but names are not useful to me</a> by Tony Morris</p>
</blockquote>
<p>이게 스칼라의 미학이다. 토니도 맞다. 틀린건 없고, 그냥 개인과 팀의 선택에 대한 문제다. 나는 &lt;-:보다 <strong>reverse</strong>를 더 선호하지만, 내가 가독성과 단순성을 선호하는만큼 토니같은 개발자들은 수학적인 순수성과 사실성을 선호한다. 이 스타일들은 항상 다른 것 같다. 토니는 라이브러리들을 개발했고, 나는 라이브러리들로 어플리케이션을 만들고, 우리 둘 다 스칼라로 개발한다. 나는 가끔 <em>var</em>를 쓰고 나중에 걷어내지만, 누군가는 그걸 질색한다.</p>
<p>그런데 팀에서 사람들이 영어, 불어, 독어 같이 한 언어가 아닌 여러 언어를 쓴다고 해보자. 이럴 때 함수 이름을 영어 동사로 써도 그러려니 한다. 내가 같이 일했던 캐나다 사람들은 영어와 불어를 쓰는 사람들이 많았고, 헝크러진 머리나 좁쌀만한 눈(역주, 미국인이 캐나다인을 놀릴 때 주로 쓰는 표현)보다는 보기 괜찮다고 확신할 수 있다. 젠장(<em>Sacré bleu!</em>)</p>
<p>스칼라처럼 독선적이지 않은 언어는 그래서 아름답다. 자기 스타일을 자유롭게 적용할 수 있고, 언어가 그걸 방해하지 않는다. &lt;-:도 <em>쓸 수 있다는</em>게 마음에 든다.</p>
<h3>5. 주머니가 허락한다면 기술지원을 받아라</h3>
<p>나는 운좋게도 타입세이프의 Nilanjan Raychaudhuri와 Roland Kuhn같은 진짜 고수들에게 배워서 Nurun에 설계 리뷰, 코드 리뷰, 페어 프로그래밍을 도입할 수 있었다. 새로운 프로그래밍 스타일을 배운 덕분에 신뢰도를 월등히 높인 프로젝트를 진행하면서 다방면으로 값으로 따질 수 없는 도움을 받았다.</p>
<p>단순히 스칼라의 함수형 스타일뿐만 배운게 아니라, 리액티브 프로그래밍 컨셉도 배웠다. Play와 Akka도. 새로운 테크닉들과 프로젝트 전반에 걸쳐 타입세이프의 도움을 많이 받았다. 우리가 항상 제대로 된 길을 가고 있는지에 대해 확신을 받았다.</p>
<p>타입세이프의 이메일 지원 역시 훌륭하다. <a href="http://typesafe.com/how/subscription" target="_blank" rel="external">지원 구독</a>은 주머니가 허락한다면 지출할 가치가 충분히 있다.</p>
<h3>6. 다양성을 포용하라</h3>
<p>스칼라 커뮤니티에는 전세계의 다양한 프로그래머들이 모여있다. 나처럼 전직 자바 개발자도 있고, 학계에서 온 사람들도 있다. 독학한 개발자도 있고 박사학위자들도 있다. 빠듯한 예산으로 사업문제를 해결하려 하는 사람들도 있고, 관심분야를 넓히려고 하는 사람들도 있다. 어플리케이션을 만드는 사람도 있고, 라이브러리를 만드는 사람도 있다.</p>
<p>커뮤니티의 모든 사람을 존중하고 이해하는게 좋은 개발자가 되는데 중요하다. StackOverflow에 단순한 질문을 올렸는데, 이해하려면 카테고리 이론을 몇년 배워야하는 난해한 답변이 달릴지도 모른다. 하지만 스칼라는 아직 새로운 언어이고 커뮤니티는 자기 색깔을 찾아가고 있다는 것을 염두에 둬라. 학계 출신이 아닌 개발자들이 스칼라 세계에 더 많아지고 더 많이 답변하다보면 토론은 조금 더 <em>이론</em> 개념보다는 <em>어플리케이션</em> 개념으로 옮겨갈 것이다.</p>
<p>답변에 실망했다면, 트위터의 <a href="https://github.com/twitter/finagle" target="_blank" rel="external">Finagle</a>이나 mDialog의 <a href="https://github.com/mDialog/smoke" target="_blank" rel="external">Smoke</a>같은 라이브러리들의 소스코드를 봐라. 두 프로젝트는 제품 레벨에서도 많이 쓰이는 구현체로 훌륭한 스칼라 예제이다. 모든 스칼라가 어마어마하게 복잡하지는 않다.</p>
<h3>7. 현실적인 목표를 설정하라</h3>
<p>자바에서 온 신입 스칼라 개발자들은 하룻밤만에 고급 스칼라, 함수형 스칼라를 배울 수 없다는 사실을 깨달아야한다. 전형적인 비지니스 어플리케이션을 성공적으로 개발하는데 고급 함수형 스칼라가 필요한건 아니다.</p>
<p>함수형 프로그래밍을 접해본 개발자라면 스칼라 스타일로 익히데 시간이 덜 걸릴 것이다. 그렇지만 팀원들 대부분이 명령형 언어 개발자들이라면 스타일을 맞춰야할 것이다.</p>
<p>그리고 팀 밸런스에 대한 것인데, 유지보수해야할 사람이 이해할 수 있는 코드를 짜야할 것이다. 아무리 전세계에서 가장 우아한 코드라도 관리할 수 없으면 쓸모없다.</p>
<h3>8. 짝코딩과 코드리뷰는 의무</h3>
<p>짝코딩을 하면 팀 전체 스타일과 기술 평균에서 너무 멀어지지 않게 해주는데 효과적이다. 마지막으로 바라는게 필멸자들이 감히 범접할 수 없는 어려운 코드를 짜거나, 팀원들이 다들 준비가 될 때까지 다시 완벽하게 작동하는 명령형 코드로 짜는 것이다. 실험은 중요하지만, git은 두었다 무엇하는가. 포크해라, 두번해라.</p>
<figure>
<img src="/blog/images/transitioning-to-scala/2.png"><figcaption class="image-caption">팀원들이 이렇게 된다</figcaption>
</figure>
<p>스칼라의 유연성 덕분에 복잡함의 칼날을 피하는 것도, 언어의 새 기능이나 스칼라의 표현력을 익히기 쉽다. 문화는 언제나 개발팀에게 중요하지만, 더 중요한건 스칼라를 처음 배울 때 다같이 페달을 밟아 나가야한다는 것이다.</p>
<h3>9. 간결함을 유지하라</h3>
<p>스칼라는 새로운 것이고, 사람들은 무엇을 써야하고 무엇을 피해야할지 여전히 배우는 중이다. 더글라스 크록포드가 스칼라를 마스터하고 <em>Scala: The Good Parts</em>를 쓰기 전까지는, 언어의 각 부분에 대한 가치를 알아서 확인해야한다. 옳고 그름은 없고, 단지 시도와 실패만 있을 뿐이다. 뭐가 더 맞는지에 대해 얼마든 질문해라.</p>
<p>Reflection API가 처음 자바에 도입되었을 때, 모든 자바 개발자들이 자신들의 지적 능력을 동원해 <strong>모든 것</strong>에 리플렉션을 사용하려고 했다. 당시 내가 개발하던 코드들은 관리하기가 더럽게 복잡해졌고, 한 개발자가 미쳐날뛰어서 이해하지 못하는 기능을 남용했다는 것 말고 다른 이유는 없었다. 모든 생소한 기능은 발을 담그기 전에 천천히 깨끗하고 심플한 코드를 짜는게 더 낫다. 고급 테크닉을 이상하게 뒤죽박죽으로 구현한 것보다 깔끔하게 명령형 스타일로 스칼라 코딩을 하는게 차라리 낫다.</p>
<figure>
<img src="/blog/images/transitioning-to-scala/3.jpg"><figcaption class="image-caption">준비가 되기 전에 깊게 들어가지마라. 천천히 가자.</figcaption>
</figure>
<p>좋은 음악처럼 좋은 코드도 우아하고 드물다. 좋은 음식에 꼭 좋은 재료가 들어가는건 아니다. 상상할 수 있는 모든 향신료가 들어간 음식을 먹고 싶어할 사람이 있을까? 코드를 쓰는 것도 그렇다. A1급 개발자가 쓴 신뢰할만한 코드는 자기가 뭘 하고 있는지 왜 하는지도 모르며 제멋대로 짠 A3/L3급 개발자의 코드보다 더 관리하기 쉽다.</p>
<h3>10. 구린 코드를 살펴봐라</h3>
<p>심각하게 구린 스칼라 코드를 짤 수도 있고, 자바, 펄, 그리고 영어도 마찬가지다.</p>
<p>하지만 구린 자바코드와 구린 스칼라코드의 중요한 차이가 있다.</p>
<p>구린 스칼라 코드는 좀 다른 방식으로 구리다. 명령형으로 구리거나, 함수형으로 구리거나, 혹은 두가지가 섞인 채로 구리거나. 이해할 수 없을 정도로 구리다면 익숙하지 않은 스타일이라서 그럴 수도 있다. 스칼라는 새로운 언어라, 자바같은 성숙된 언어처럼 바로 안티패턴을 발견해내는게 아직은 어렵다. 그래서 개발팀들이 아름다운 코드를 구리다고 착각할 수도 있고, 구린 코드를 아름답다고 착각하게 될 수도 있다. 개발자들은 배운대로 구린 패턴을 짜기 시작하면 나중에는 더 구린 코드가 나온다. 그렇게 악순환이 된다.</p>
<p>나중에 고치려고 하는 것보다 처음부터 피하는게 더 좋다.</p>
<p>똑똑한 개발자가 스칼라로 이상하게 코딩한다면 불러봐라. 질문해라. 익히지 못한 언어에 대해 추측하지마라. 최악의 경우는, 잘못짰으면서 우아한 코드라고 생각은 하는데, <em>왜</em> 우아한지 이해하지 못하는 경우다.</p>
<h3>11. 스칼라는 단지 퍼즐의 일부분</h3>
<p>웹 어플리케이션을 개발하는 방법은 10년전에 비하면 매우 다양하다. 요새는 스칼라, 플레이, AngularJS, MongoDB 앱을 개발한다. 내가 짜는 코드 대부분은 클라이언트단이다. 몇년간은 스칼라보다 Angular를 더 많이 짰는데, 나쁘다는게 아니라 그냥 현실이 그렇다.</p>
<p>스칼라의 미학은 자바처럼 쓸데없는 밑바닥을 만들어야하거나 루비같은 동적 언어의 불안함을 걱정할 필요없이 깔끔하고 안정적이고 성능좋은 서버단 코드를 짤 수 있게 해준다는 것이다. 스칼라로 짠 서버쪽 로직은 견고하기에 클라이언트쪽 코드를 안정적으로 짜는데 시간을 투자할 수 있다.</p>
<p>스칼라의 모든 쪽에서 마스터가 되고 싶어하는만큼 파고들어야할 기술들이 너무 많다. HTML5, SASS, AngularJS, RequireJS, SQL, MongoDB, 또, 또, 또.</p>
<p>한 언어의 모든 면을 마스터할 시간은 없겠지만, 스칼라는 맛을 보기만 해도 괜찮은 기술이다. <a href="http://www.reactivemanifesto.org/" target="_blank" rel="external">Reactive Programming</a>은 다음 세대의 대세가 될 것이며 그 패러다임 전환의 선두에 스칼라가 있을 것이라 믿는다. 성능과 안정성을 모두 얻을 수 있는 리엑티브 어플리케이션을 무시하기는 힘들다.</p>
<p>요즘엔 대부분 묵직한 XML 대신 JSON을 쓴다. SOA 패턴 대신 REST를 쓴다. 데스크탑 대신 모바일을 쓴다. 어마어마한 크기의 데이터에서 필요한 정보를 뽑아낼 때, Akka의 성능이라면 막대한 하드웨어를 투자하지 않고서도 가능하다.</p>
<p>스칼라는 퍼즐의 한 부분일 뿐이지만, 새로운 종류의 개발을 위해 필요한 다른 많은 부분들의 심장과도 같다.</p>
<h3>12. 스칼라를 배우면 더 좋은 프로그래머가 된다</h3>
<p>직장인 개발자가 자기 영역을 넓히는건 <em>정말</em> 드문 일이다. 소프트웨어 개발에서 완전히 다른 접근법을 배워본게 마지막으로 언제인가?</p>
<p>마지막 전환(그리고 내 경력에서 겪었던 유일한 전환)은 절차지향 언어에서 객체지향 언어로의 변환이었다. CIBC에서 인턴하던 1998년에 운좋게도 첫 자바 어플리케이션 개발자 중 하나가 될 수 있었다. 대부분의 개발자들은 전직 COBOL이나 C였다가 전환하는 시점이었다. 요새는 뭐든 다 자바를 쓰지만, 당시에 윈도우와 OS/2에 모두 배포해야하는 상황에서 자바는 매우 실용적이었다.</p>
<p>2-30년 경력의 개발자들(몇명은 실제로 펀치카드로 프로그래밍을 해봤던)과 일하면서 좋은 경험을 쌓았고, 한가지 스타일에 매이면 안된다는 것을 깨달았다. 자바를 배울 때 JCL도 관리해야했다. 바로 다시 복귀하기 몇달전까지는 old COBOL과 360 어셈블리도 파고들었다. 넓게 보자. JCL과 COBOL이 섹시한 언어는 아니지만 필요한 분야에서는 괜찮은 언어다. 인턴시절 스몰토크에서 엑셀까지 모든 것을 겪어볼 수 있었다.  엑셀은 처음 접한 함수형 프로그래밍이다. (역주: 엑셀이 함수형 프로그래밍을 지원하는지에 대한 <a href="http://programmers.stackexchange.com/questions/125990/questions-over-excel-programming" target="_blank" rel="external">StackExchange</a>의 글이 댓글에 있다.)</p>
<p>스칼라는 부당한 평을 많이 받았다. 어떤 개발자들은 생각을 깊게 하기보다는 잠깐 시도해보고 익숙한 언어로 도망친다. 문제는 그 사람들이 인터넷에 남긴 불평들 때문에 관심있어하는 개발자들에게 언어의 가치가 잘못 전달될 수도 있다.</p>
<p>스칼라에 대한 불만을 읽는다면 누가 썼는지 찾아보기를. 다른걸 원한 사람일 수도 있다. 쉽게 흔들리지 말고, 불평하는 사람들에게 얽매이지 마라. 점점 널리 퍼져가는 스칼라의 성공사례들을 찾아보기를 바란다.</p>
<h3>결론</h3>
<p>스칼라는 기술뿐만이 아니라 문화적인 투자다. 투자할만한 가치가 있는 보상이 있는데, 어쨋든 해봐야하지 않을까? 확장가능하고 믿을만하고 관리하기 편한 프로젝트를 진행중이라면, 혹은 프로그래머로서 사고를 확장하고 싶다면 단언컨데 스칼라는 할만 하다. 기본만 있으면 보이는 것만큼 어렵지도 않다.</p>
<p>스칼라는 실무에서도 쓸만하다는걸 기억해라, 아니 이미 쓰이고 있다.</p>
<style type="text/css">
.image-caption {
position: relative;
width: 100%;
text-align: center;
left: 0;
margin-top: 10px;
letter-spacing: .01rem;
font-weight: 400;
font-style: italic;
font-size: 14px;
line-height: 1.4;
color: #666665;
outline: 0;
z-index: 300;
}
</style></div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/blog/tags/scala/" class="post__tag__link">scala</a></li><li class="post__tag__item"><a href="/blog/tags/translation/" class="post__tag__link">translation</a></li></ul><a href="https://github.com/seoh/blog/tree/master/source/_posts/transitioning-to-scala.md" class="post__foot-link u-fr">Pull Request</a><a href="https://github.com/seoh/blog/issues/new" class="post__foot-link u-fr">Tell me</a></footer></article></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2015 Seoh Char</div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><span title="Next" class="page-menu__link icon-arrow-right page-menu__link--disabled"></span></li></menu></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-52090105-1');ga('send','pageview');
</script></body></html>