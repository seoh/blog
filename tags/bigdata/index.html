<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="description" content="most opinionated blog"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/blog/rss.xml" title="devthewild" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>bigdata - devthewild</title><link rel="stylesheet" href="/blog/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"><a href="/blog/">devthewild</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/blog/" class="head-nav__link">Home</a></li><li class="head-nav__item"><a href="/blog/archives" class="head-nav__link">Archives</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2015-06-28T17:46:17.000Z" class="post__time">29th Jun, 2015</time><h1 class="post__title"><a href="/blog/2015/06/29/big-data-with-spark-5-week/">Spark로 빅데이터 입문, 5주차 및 후기</a></h1></header><div class="post__main echo"><h1>5주차. 스파크로 머신러닝 시작</h1>
<p>이번 주의 제목은 노트가 아니라 메모 겸 후기다.
5주차에는 수업이 없고 과제와 퀴즈만 있다.</p>
<h3>Lab 4. 스파크로 머신러닝 시작</h3>
<p>영화 목록과 평점 이력을 트레이닝 셋으로 해서 내가 영화 평점을 몇 개 입력해서
다른 영화의 내 평점을 예측하도록 기계학습을 해보는 과제이다.
스파크의 머신러닝 라이브러리(MLlib)에서의 협업 필터링(Collaborative Filtering)
에서는 ALS(Alternating Least Squares)라는 알고리즘을 사용하는데, 유사도를
평가하는 데는 <a href="https://ko.wikipedia.org/wiki/%ED%8F%89%EA%B7%A0_%EC%A0%9C%EA%B3%B1%EA%B7%BC_%ED%8E%B8%EC%B0%A8" target="_blank" rel="external">평균 제곱근 오차(Root Mean Square Error; RMSE)</a>
라는 방법을 사용한다. 정확한 의미는 이해하지 못했지만, 순서대로 따라가니 풀 수
있었다.</p>
<h3>Lab 4. Quiz</h3>
<p>RMSE의 값에 대한 의미(예상값과 실제값이 같을 때의 결괏값)를 묻는 간단한
문제들이었다.</p>
<h1>후기</h1>
<p><img src="/blog/images/big-data-with-spark-5-week/score.png" alt=""></p>
<p>세 번째 과제를 진행하다가 TF-IDF에 대한 이해가 부족해서 자료를 찾다가 영어로 된
글을 계속 읽다 보니 지루해져서 계속 미뤘는데, 결국 기한을 넘겨서 그냥 하던 데
까지만 제출했다. 그래서 이번 과제는 알고리즘(ALS)에 대한 이해가 부족해도 그냥
최대한 설명을 자세히 읽고 이리저리 시도해보다가 다 풀긴 했다.</p>
<p>내용을 다 이해하지는 못했지만, 좋은 입문 강의다. 강의 시작에서 언급했듯이 파이썬
기본 문법 정도만 알고 있으면 진행하는 데 큰 무리는 없을 것으로 생각한다. 어차피
기초적인 개념부터 설명하는 강의라, 과제할 때 파이썬 문법의 문제인지 스파크를
잘못 사용한 것인지에 대해 구분할 수 있을 정도면 되지만, 그렇지 않을 때는
어렵다기보다 상당히 까다로울 것으로 생각한다.</p>
<p>기초적인 개념부터 설명한다고 위에서 말했지만, 개념과 역사, 사례를 넓게 훑고
지나가면서 책, 논문 등의 자료들을 레퍼런스로 많이 소개해서 깊게 알고 싶은 분야에
대한 좋은 진입점을 제시해준다. 당연히 입문 강의는 그렇다고 생각하지만 A to Z로
가르쳐주길 원하는 사람에게는 맞지 않는 강의다.</p>
<p>가장 마음에 들었던 것들을 꼽자면, 하나는 모든 강의가 5분 내로 되어있다는 점이고
나머지 하나는 <a href="/blog/2012/11/17/after-coursera-fppis-and-test">FPPiS</a>처럼 과제가
단계별 테스트로 되어있다는 점이다.</p>
<p>입문 강의라 많은 개념을 깊게 설명할 수 없으므로 개념별로 간단하게 설명을
하기 지나가는데, 덕분에 지하철/버스에서 이동 중에 틈틈이 듣고 나중에 1.5배속으로
빠르게 복기하면서 퀴즈를 풀면 두세 번 반복하는 느낌이라 오래(과제가 끝나기 전까지)
기억에 남는다. 이동하는 시간은 어차피 낭비하는 시간이라고 생각했는데 꽤 요기하게
쓰였다.</p>
<p>그리고 단계별 테스트로 되어있다는 것도 입문 과목에서 큰 장점이라고 생각하는데,
과제를 던져주고 알아서 해결하는 방법을 찾는 것도 중요하지만 가장 정석적인
단계를 알려주기 위해서는 과제를 단계별로 나누고 각각의 단계를 어떻게 진행할지에
대한 설명을 사이사이에 주고, 하나가 통과해야 그다음으로 넘어갈 수 있으니 다음
문제를 보고 이전 문제의 의도를 가늠해볼 수 있기도 하다. 물론 하나가 막혀버리면
그다음의 모든 것을 못한다는 게 단점이지만 그렇게 난이도 조절을 못 한 과제는
아니라고 생각한다.</p>
<hr>
<p>사실 다 마치고 나서도 이제 무엇을 해야할지 막막하지만, 소재의 문제이지 방법에
대한 것은 한번 과정을 거쳤으니 어떤 식으로 접근해야 할지에 대한 감을 대충 알았다.</p>
<p>참고로 edX에서는 한 학교가 주제에 따라 코스웍을 제공하는 X시리즈 인증이 있는데,
이 강의(CS100.1x)는 Berkeley에서 진행하는 빅데이터 코스인 BerkeleyX의 두 단계 중
첫 번째다. 두 번째 단계(CS109.1x)는 <a href="https://www.edx.org/course/scalable-machine-learning-uc-berkeleyx-cs190-1x" target="_blank" rel="external">확장 가능한 머신 러닝(Scalable Machine Learning)</a>
이라는 제목으로 29일부터 시작한다. 수학적 사고와 알고리즘 개념, 그리고 기본적인
머신 러닝에 대한 개념이 필요하며, 알고리즘, 확률, 선형대수, 미적분을 접해본 적이
있고, 파이썬 경험이 있거나 빠르게 익힐 수 있으면 된다. 듣긴 하겠지만, 이 과목처럼
완주하겠다는 생각으로 듣는 것은 아니고 재미있는 부분까지만.</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/blog/tags/bigdata/" class="post__tag__link">bigdata</a></li><li class="post__tag__item"><a href="/blog/tags/spark/" class="post__tag__link">spark</a></li></ul><a href="https://github.com/seoh/blog/tree/master/source/_posts/big-data-with-spark-5-week.md" class="post__foot-link u-fr">Pull Request</a><a href="https://github.com/seoh/blog/issues/new" class="post__foot-link u-fr">Tell me</a></footer></article><article class="post"><header class="post__head"><time datetime="2015-06-25T18:24:00.000Z" class="post__time">26th Jun, 2015</time><h1 class="post__title"><a href="/blog/2015/06/26/big-data-with-spark-4-week/">Spark로 빅데이터 입문, 4주차 노트</a></h1></header><div class="post__main echo"><h1>4주차. 데이터 품질, 탐헌적 데이터 분석과 머신 러닝</h1>
<h3>Lecture 7. 데이터 품질</h3>
<p>데이터 클리닝</p>
<ul>
<li>왜곡: 처리과정에서 변질된 표본들</li>
<li>선택편견: 값에 따른 표본의 가능도(likelihood)</li>
<li>좌우검열: 데이터가 무한대일 때 시작과 끝을 어떻게 자를지</li>
<li>의존성: 표본이 독립적인지 아닌지에 대한 판단</li>
</ul>
<ul>
<li>정확성과 (과정의)간소에 대한 트레이드오프</li>
<li>단위 통일, 중복 제거 등</li>
</ul>
<p>문제</p>
<ul>
<li>텍스트 파싱</li>
<li>같은 엔티티 다른 표현(2 vs two, NYC vs NewYork)</li>
<li>비구조적-구조적 전환시 primary key</li>
<li>너무 길어서 잘리는 필드</li>
<li>형식 문제(특히 날짜)</li>
</ul>
<p>수집</p>
<ul>
<li>과정에서 무결성 체크</li>
<li>구조에 없는건 기본값</li>
</ul>
<p>전송</p>
<ul>
<li>신뢰할만한 프로토콜인가</li>
<li>받은 데이터의 확인이 가능한가(checksum)</li>
</ul>
<p>분석의 어려움</p>
<ul>
<li>크기, 성능</li>
<li>모델에 적용</li>
<li>전문지식 부족</li>
<li>다트판(때려맞추기)</li>
<li>대충 경험(특정 상황에만 맞는 분석)</li>
</ul>
<p>품질 측정</p>
<ul>
<li>스키마 일치</li>
<li>정확성, 접근성, 해석가능</li>
<li>Lab2에서 정규식을 통한 형식 일치 확인</li>
</ul>
<p>용어?</p>
<ul>
<li>개체 식별(entity resolution)</li>
<li>중복 검출(DeDup: Detection Duplicated)</li>
</ul>
<p>표준화</p>
<ul>
<li>USPS에서 제공하는 <a href="http://pe.usps.com/text/pub28/welcome.htm" target="_blank" rel="external">주소 표준가이드</a></li>
<li>다른 필드 참고 등 식별 힌트</li>
</ul>
<h3>Lecture 8. 탐험적 데이터 분석과 머신 러닝</h3>
<p>기술통계 vs 추론통계(<a href="https://ko.wikipedia.org/wiki/%ED%86%B5%EA%B3%84%ED%95%99#.EC.B6.94.EB.A1.A0_.ED.86.B5.EA.B3.84" target="_blank" rel="external">위키피디아</a>)</p>
<p>업무에서의 목적</p>
<ul>
<li>간단한 통계</li>
<li>가설 검증</li>
<li>분류</li>
<li>예측</li>
</ul>
<p><a href="http://www.amazon.com/dp/0201076160" target="_blank" rel="external">탐험적 데이터분석</a></p>
<ul>
<li>기본 테크닉 소개
<ul>
<li><a href="https://en.wikipedia.org/wiki/Five-number_summary" target="_blank" rel="external">Five-number summary</a></li>
<li>box plot, stem and leaf diagram</li>
</ul>
</li>
<li>통계요약의 문제: 같은 요약이라도 다른 데이터일 수 있다</li>
</ul>
<p>정규 분포</p>
<ul>
<li>평균, 표준편차</li>
<li>중심극한정리(Central Limit Theorem): n이 무한대로 가면 정규분포에 가까워진다.</li>
</ul>
<p>다른 중요한 분포</p>
<ul>
<li><a href="https://ko.wikipedia.org/wiki/%ED%91%B8%EC%95%84%EC%86%A1_%EB%B6%84%ED%8F%AC" target="_blank" rel="external">프아송 분포</a></li>
<li>이항 분포, 다항 분포</li>
</ul>
<p>Spark의 mllib</p>
<ul>
<li>NumPy와 함께 사용가능(pySpark &gt;= 0.9)</li>
<li>여기에서는 영화평점 예측
<ul>
<li>collaborative filtering</li>
<li>k rank = user(a) x movie feature(b)</li>
</ul>
</li>
</ul>
<h3>Lab 3. 텍스트 분석과 개체 식별</h3>
<ol>
<li>텍스트 유사성으로 개체 식별 - Bags of Words</li>
</ol>
<ul>
<li><a href="http://darkpgmr.tistory.com/125" target="_blank" rel="external">Bag of Words 기법</a></li>
</ul>
<ol start="2">
<li>텍스트 유사성으로 개체 식별- TF-IDF를 사용한 가중치 적용된 BOW</li>
</ol>
<ul>
<li><a href="https://ko.wikipedia.org/wiki/TF-IDF" target="_blank" rel="external">TF-IDF</a></li>
</ul>
<ol start="3">
<li>텍스트 유사성으로 개체 식별- 코사인 유사도(Cosine Similarity)</li>
<li>역참조(inverted index)를 통한 효율적인 개체 식별</li>
<li>그래프(plot)을 통한 결과 분석</li>
</ol>
<h3>Lab 3. 퀴즈</h3>
<p>Lab 3에서 배운 것들 재확인</p>
<hr>
<p><a href="https://github.com/Kapeli/Dash-User-Contributions/tree/master/docsets/pyspark" target="_blank" rel="external">pySpark Docset</a></p>
<ul>
<li><a href="https://kapeli.com/dash" target="_blank" rel="external">Dash</a>용 pySpark API문서</li>
<li>설정의 다운로드 -&gt; 좌하단의 사용자 제공(User Contibuted) -&gt; pySpark 검색</li>
</ul>
<hr>
<ul>
<li><a href="https://courses.edx.org/c4x/BerkeleyX/CS100.1x/asset/Week4Lec7.pdf" target="_blank" rel="external">Lecture 7 slides</a></li>
<li><a href="https://courses.edx.org/c4x/BerkeleyX/CS100.1x/asset/Week4Lec8.pdf" target="_blank" rel="external">Lecture 8 slides</a></li>
</ul>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/blog/tags/bigdata/" class="post__tag__link">bigdata</a></li><li class="post__tag__item"><a href="/blog/tags/spark/" class="post__tag__link">spark</a></li></ul><a href="https://github.com/seoh/blog/tree/master/source/_posts/big-data-with-spark-4-week.md" class="post__foot-link u-fr">Pull Request</a><a href="https://github.com/seoh/blog/issues/new" class="post__foot-link u-fr">Tell me</a></footer></article><article class="post"><header class="post__head"><time datetime="2015-06-14T14:43:28.000Z" class="post__time">14th Jun, 2015</time><h1 class="post__title"><a href="/blog/2015/06/14/big-data-with-spark-3-week/">Spark로 빅데이터 입문, 3주차 노트</a></h1></header><div class="post__main echo"><h3>Lecture 5. 반구조적 데이터</h3>
<p>자료 형태</p>
<ul>
<li>구조적: 정형(schema) 데이터. RDB, formatted msg</li>
<li>반구조적: schema를 그때그때. XML, JSON, mp3tag</li>
<li>비구조적: plain text</li>
</ul>
<p>파일이란</p>
<ul>
<li>byte의 나열</li>
<li>FS를 통한 상하구조</li>
<li>POSIX interface(이건 왜?)</li>
</ul>
<p>테이블</p>
<ul>
<li>처음부터 구조를 잘 짜야</li>
<li>같은 데이터도 타입문제(2 vs 2.0)</li>
<li>이력관리</li>
</ul>
<p>취합 문제</p>
<ul>
<li>필드가 다를 때</li>
<li>데이터 단위가 다름</li>
<li>같은 값인데 표현이 다름</li>
</ul>
<p>pandas</p>
<ul>
<li>data analysys + modeling for python</li>
<li>DataFrame: named column</li>
<li>R도 비슷한 data frame 지원</li>
</ul>
<p>DF in pySpark</p>
<ul>
<li>1.3부터 RDD 확장으로 지원</li>
<li>pandas, R의 DF와 같지만 분산환경</li>
<li>pandas DF와 convert 쉬움</li>
<li>pandas -&gt; pySpark시 driver 메모리 꽉 찰 수 있음 주의</li>
<li>RDD는 Scala구현체가 Python구현체보다 두 배 이상 빠름</li>
<li>DF는 RDD Scala보다 두 배쯤 빠르고 Py/Scala 비슷</li>
</ul>
<p>Apache Common Log Format의 데이터를 분석해보자</p>
<ul>
<li>컨텐츠 통계: status code, size</li>
<li>404 횟수</li>
</ul>
<ul>
<li>하루에 단일host는 얼마나?</li>
<li>하루에 요청은 얼마나?</li>
<li>호스트당 평균 요청은?</li>
<li>하루에 404는?</li>
</ul>
<p>로그 마이닝</p>
<ul>
<li>splunk를 통해 event log, disk error, network, cpu/memory usage 등 통계 및 분석</li>
</ul>
<p>read/write</p>
<ul>
<li>binary가 항상 빠르다</li>
<li>압축 알고리즘과 rw속도는 어느 정도 trade-off</li>
</ul>
<h3>Lecture 6. 구조적 데이터</h3>
<p>RDB</p>
<ul>
<li>relation: schema + instance</li>
<li>sparse에 약하다</li>
</ul>
<p>SQL 기초</p>
<ul>
<li>select, (inner, outer)join</li>
<li>join in Spark</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = sc.parallelize([(<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">4</span>)])</span><br><span class="line">y = sc.parallelize([(<span class="string">"a"</span>, <span class="number">2</span>), (<span class="string">"a"</span>, <span class="number">3</span>)])</span><br><span class="line">x.join(y).collect</span><br><span class="line">// [(<span class="string">'a'</span>, (<span class="number">1</span>, <span class="number">2</span>)), (<span class="string">'a'</span>, (<span class="number">1</span>, <span class="number">3</span>))]</span><br><span class="line"></span><br><span class="line">x = sc.parallelize([(<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">4</span>)])</span><br><span class="line">y = sc.parallelize([(<span class="string">"a"</span>, <span class="number">2</span>)])</span><br><span class="line">x.leftOuterJoin(y).collect()</span><br><span class="line">// [(<span class="string">'a'</span>, (<span class="number">1</span>, <span class="number">2</span>)), (<span class="string">'b'</span>, (<span class="number">4</span>, <span class="keyword">None</span>))]</span><br><span class="line"></span><br><span class="line">x.rightOuterJoin(y).collect()</span><br><span class="line">// [(<span class="string">'a'</span>, (<span class="number">1</span>, <span class="number">2</span>))]</span><br><span class="line"></span><br><span class="line">x = sc.parallelize([(<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">4</span>)])</span><br><span class="line">y = sc.parallelize([(<span class="string">"a"</span>, <span class="number">2</span>), (<span class="string">"c"</span>, <span class="number">8</span>)])</span><br><span class="line">x.fullOuterJoin(y).collect()</span><br><span class="line">// [(<span class="string">'a'</span>, (<span class="number">1</span>, <span class="number">2</span>)), (<span class="string">'c'</span>, (<span class="keyword">None</span>, <span class="number">8</span>)), (<span class="string">'b'</span>, (<span class="number">4</span>, <span class="keyword">None</span>))]</span><br></pre></td></tr></table></figure>
<h3>Lab 2. 로그 분석</h3>
<p>Apache Log Format을</p>
<ol>
<li>정규식으로 나눠서</li>
<li>종류별 aggregation</li>
<li>key, value로 나눠서 plot</li>
<li>그리기 위해 2, 3번의 반복이 많아 분량에 비해 생각할꺼리는 적음</li>
<li>아마도 python 사용에 익숙치 않은 사람들을 위한 단순반복으로 추정</li>
</ol>
<p>tip.</p>
<p>저번 과제에 비해 데이터가 커서연산할 때 시간이 많이 걸리므로 REPL이나
편한 python 툴을 꺼내놓고 기다리면서 다음 셀에서 어떻게 하면 될지 간단히
테스트해보면 좋다.</p>
<p><img src="/blog/images/big-data-with-spark-3-week/ptpython.png" alt=""></p>
<hr>
<ul>
<li><a href="https://courses.edx.org/c4x/BerkeleyX/CS100.1x/asset/Week3Lec5.pdf" target="_blank" rel="external">Lecture 5 slides</a></li>
<li><a href="https://courses.edx.org/c4x/BerkeleyX/CS100.1x/asset/Week3Lec6.pdf" target="_blank" rel="external">Lecture 6 slides</a></li>
</ul>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/blog/tags/bigdata/" class="post__tag__link">bigdata</a></li><li class="post__tag__item"><a href="/blog/tags/spark/" class="post__tag__link">spark</a></li></ul><a href="https://github.com/seoh/blog/tree/master/source/_posts/big-data-with-spark-3-week.md" class="post__foot-link u-fr">Pull Request</a><a href="https://github.com/seoh/blog/issues/new" class="post__foot-link u-fr">Tell me</a></footer></article><article class="post"><header class="post__head"><time datetime="2015-06-10T12:18:51.000Z" class="post__time">10th Jun, 2015</time><h1 class="post__title"><a href="/blog/2015/06/10/big-data-with-spark-1-2-week/">Spark로 빅데이터 입문, 1-2주차 노트</a></h1></header><div class="post__main echo"><p>edX에서 <a href="https://courses.edx.org/courses/BerkeleyX/CS100.1x/1T2015" target="_blank" rel="external">Spark로 빅데이터 입문(Introduction to Big Data with Apache Spark)</a>을
듣고 있다. UC Berkeley의 Anthony Joseph 교수가 진행하는 수업으로, 실제 데이터를 가지고 과제
4개를 진행하면서 Spark로 빅데이터 분석하는 방법을 배운다고 하는데, 수업 난이도 자체는 높지 않다.
대상은 Python 경험자로 분산 컴퓨팅/Spark에 대한 지식은 없어도 된다고 되어있다. 환경 설정도
Jupyter(IPython Notebook의 새 이름)와 PySpark가 이미 세팅된 환경을 Vagrant로 제공해주는데,
Vagrant의 이름만 알고 있는 정도였지만 동영상에서 OS별로 제공하는 동영상을 보고 따라하는데 무리는 없었다.</p>
<p>실습은 노트북 파일에서 비어있는 부분을 채우면서 진행하면 되는데, 의도에 대한 설명은 코드 위에 충분히
자세하게 되어있고 단계별 진행이다보니 정확히 읽지 않아도 코드를 보면서 따라가면 유추가 가능하다.
단순히 유행어(Buzzword) 이상으로 Big Data나 Spark에 대해 배워보고 싶은 사람들에게 추천할 겸,
몇달 뒤에 잊어먹을 나 자신을 위해서 기록을 남겨본다.</p>
<h1>1주차</h1>
<p>환경설정: Jupyer + PySpark가 세팅된 vagrant 올리기</p>
<p>수업 목표</p>
<ul>
<li>Data Science를 배워보자</li>
<li>실제 데이터를 다루는 과정</li>
<li>Spark(w/ mllib)를 써보자</li>
</ul>
<h3>Lecture 1. Big Data와 Data Science 소개</h3>
<ul>
<li>데이터 분석의 역사</li>
<li>원인 ≠ 상관관계</li>
<li>충분한 데이터가 필요</li>
<li>현재를 분석하는건 쉽고 미래를 예측하는건 어렵다</li>
<li>사건에 대한 중요한 요인을 모두 알고 있어야한다</li>
<li>(MySpcae 사례를 통한 페이스북 유행시기 추정 -&gt; 실패)</li>
</ul>
<p>빅데이터는 어디에서?</p>
<ul>
<li>사용자들이 올리는 컨텐츠들(웹/모바일) - 페이스북, 인스타그램, 옐프</li>
<li>생체정보/과학쪽 연산</li>
</ul>
<p>그래프 데이터</p>
<ul>
<li>많은 데이터들이 그래프 구조</li>
<li>SNS, 네트워크 등</li>
</ul>
<p>사람이 보기에 너무 많은 정보</p>
<ul>
<li>아파치 서버 로그</li>
<li>IoT의 센서 측정기록</li>
</ul>
<p>빅데이터를 어떻게 다룰까</p>
<ul>
<li>Crowdsourcing</li>
<li>Physical modeling</li>
<li>Sensing</li>
<li>Data Assimilation</li>
</ul>
<p>많은 사람들에게서 정보를 얻어 분석한 다음에 중요한 정보를 시각화</p>
<h3>Lecture 2. Data Science는 어떻게? 데이터 준비하기</h3>
<ul>
<li>코딩 + 도메인 지식만으로는 잘못된 분석의 가능성</li>
<li>Data Science = 코딩 + 도메인 + 통계지식</li>
</ul>
<p><a href="http://drewconway.com/zia/2013/3/26/the-data-science-venn-diagram" target="_blank" rel="external">The Data Science Venn Diagram</a></p>
<p>Database와 Data Science의 차이</p>
<ul>
<li>데이터가 중요하다 / 싸다</li>
<li>원자성이 중요 / 결과적으로 유지만되면 오케이</li>
<li>과거를 조회 / 미래를 예측</li>
<li>정해진 복잡도 / 하다보면 됨</li>
</ul>
<p>방법</p>
<ul>
<li>Jim Gray 모델 vs Ben Fry 모델 vs Jeff Hammerbacher 모델</li>
</ul>
<p>어려움</p>
<ul>
<li>실제 데이터는 너무 더러움</li>
<li>이전에 발견한 패턴/가설이 선입견</li>
</ul>
<p>준비: ETL</p>
<ul>
<li>extract: 데이터 추출</li>
<li>transform: 가공</li>
<li>load: 모아놓는다</li>
</ul>
<h1>2주차</h1>
<h3>Lecture 3. 빅 데이터, Spark</h3>
<p>왜 필요한가?</p>
<ul>
<li>페이스북의 하루 로그는 60TB</li>
<li>이제 머신 하나에서 다룰 수 없다</li>
</ul>
<p>거대한 문서에서 단어를 세는 예제</p>
<ul>
<li>머신 n-to-1
<ul>
<li>문단 별 단어 카운트는 n개에서 나눠서 해도 된다</li>
<li>합치는 작업을 1개에서 한다면 병목</li>
</ul>
</li>
<li>머신 n-to-n
<ul>
<li>합치는 작업도 단어별로 n개에서 나눠서</li>
<li>이게 Map/Reduce 개념</li>
</ul>
</li>
<li>문제
<ul>
<li>머신끼리 데이터 보내는건 느리다</li>
<li>하나가 실패하면? -&gt; 그 머신만 다시 시작</li>
<li>하나가 느리면? -&gt; 하나 더 돌리고 먼저 끝난걸 선택</li>
</ul>
</li>
<li>문제 2
<ul>
<li>작업을 반복해서할 때 디스크에 저장하면 I/O가 병목</li>
<li>메모리에 올려서 작업하면? -&gt; Spark</li>
</ul>
</li>
</ul>
<p>Spark</p>
<ul>
<li>위에서 말한 실패하거나 느린 노드를 자동으로 처리</li>
<li>Core와 컴포넌트 4개 Spark SQL, Spark Streaming, MLlib, GraphX로 구성</li>
<li>disk에 넣기 위해 serialization/deserialization 할 필요가 없으므로 100배 이상 빠르다</li>
</ul>
<p>특징</p>
<ul>
<li>다양한 경우에 쓸 수 있는 엔진</li>
<li>리니지(immutable을 이용한 이력관리)의 lazy eval</li>
</ul>
<h3>Lecture 4. Spark 기초</h3>
<ul>
<li>어플리케이션(driver)에서 SparkContext로 시작</li>
<li>worker는 클러스터 혹은 로컬 스레드</li>
<li>분산된 worker의 추상화가 RDD</li>
</ul>
<p>맨 처음 실행하면</p>
<ul>
<li>SparkContext 객체의 인스턴스 <code>sc</code> 생성</li>
<li><code>sc</code>로 로컬의 worker 접근, 혹은 hdfs, mesos 접근</li>
</ul>
<p>RDD는</p>
<ul>
<li>만들어지면 불변</li>
<li>transform되는 과정(lineage)을 추적해서 재사용 가능</li>
<li>파티션을 설정하면 그만큼 병렬처리</li>
</ul>
<p>연산은</p>
<ul>
<li>transformation, action 두 종류</li>
<li>transform: lazy eval, action까지 미뤄둠</li>
<li>persis(cache)는 메모리/디스크 저장</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">rDD = sc.parallelize(data, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>혹은</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = sc.textFile(<span class="string">"README.md"</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>transformation</p>
<ul>
<li>map, filter, distinct, flatMap,</li>
</ul>
<p>action</p>
<ul>
<li>바로 계산</li>
<li>reduce, take, collect, takeOrdered</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lines = sc.textFile(<span class="string">"..."</span>, <span class="number">4</span>)</span><br><span class="line">comments = lines.filter(isComment)</span><br><span class="line"><span class="keyword">print</span> lines.count(), comments.count()</span><br></pre></td></tr></table></figure>
<p>lines 연산을 한번, lines+comments 연산을 한번해서 중복. 그럴 때는 중간에 <code>lines.cache()</code></p>
<p>key-value transformation</p>
<ul>
<li>reduceByKy, sortByKe, groupByKey</li>
<li>groupByKey는 데이터가 이동하므로 네트워크/대량에서는 주의</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdd // [(<span class="number">1</span>,<span class="number">2</span>), (<span class="number">3</span>,<span class="number">4</span>), (<span class="number">3</span>,<span class="number">6</span>)]</span><br><span class="line">rdd.reduceByKey(<span class="keyword">lambda</span> a, b: a + b) // [(<span class="number">1</span>,<span class="number">2</span>), (<span class="number">3</span>,<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>
<p>closure</p>
<ul>
<li>broadcase: driver가 쓰면 worker들이 읽기 가능</li>
<li>accumulator: worker들이 쓰기만 가능 driver만 접근가능</li>
</ul>
<h1>Lab 1. Spark 과제</h1>
<p>구텐베르크 프로젝트에서 셰익스피어 전집의 데이터로 단어 세기</p>
<ul>
<li>특수문자 제거</li>
<li>띄어쓰기로 단어 구분</li>
<li>중복 제거를 위해 소문자로 변환</li>
<li>최빈 15개 단어</li>
</ul>
<hr>
<p>참고로 강의노트(PDF)가 공개되어있다.</p>
<ul>
<li><a href="https://courses.edx.org/c4x/BerkeleyX/CS100.1x/asset/Week1Lec1.pdf" target="_blank" rel="external">Lecture 1 slides</a></li>
<li><a href="https://courses.edx.org/c4x/BerkeleyX/CS100.1x/asset/Week1Lec2.pdf" target="_blank" rel="external">Lecture 2 slides</a></li>
<li><a href="https://courses.edx.org/c4x/BerkeleyX/CS100.1x/asset/Week2Lec3.pdf" target="_blank" rel="external">Lecture 3 slides</a></li>
<li><a href="https://courses.edx.org/c4x/BerkeleyX/CS100.1x/asset/Week2Lec4.pdf" target="_blank" rel="external">Lecture 4 slides</a></li>
</ul>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/blog/tags/bigdata/" class="post__tag__link">bigdata</a></li><li class="post__tag__item"><a href="/blog/tags/spark/" class="post__tag__link">spark</a></li></ul><a href="https://github.com/seoh/blog/tree/master/source/_posts/big-data-with-spark-1-2-week.md" class="post__foot-link u-fr">Pull Request</a><a href="https://github.com/seoh/blog/issues/new" class="post__foot-link u-fr">Tell me</a></footer></article></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2015 Seoh Char</div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><span title="Next" class="page-menu__link icon-arrow-right page-menu__link--disabled"></span></li></menu></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-52090105-1');ga('send','pageview');
</script></body></html>