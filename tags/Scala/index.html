<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="description" content="most opinionated blog"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="devthewild" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Scala - devthewild</title>
<link rel="stylesheet" href="/css/main.css">
<!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><meta name="generator" content="Hexo 5.4.0"></head><body><header class="head"><h1 class="head-title u-fl"><a href="/">devthewild</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Home</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archives</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2021-06-01T13:44:34.000Z" class="post__time">June 1, 2021</time><h1 class="post__title"><a href="/2021/06/01/after-coursera-epis/">Coursera - EPiS 후기</a></h1></header><div class="post__main echo"><p>Scala 3(a.k.a Dotty)의 업데이트와 함께 새로운 스칼라 입문 코스, <a target="_blank" rel="noopener" href="https://www.coursera.org/learn/effective-scala">Effective Programming in Scala</a>가 코세라에 올라왔다. <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=MSDJ7ehjrqo">소개 영상</a>에 의하면 전제조건은 다른 프로그래밍 언어의 경험이 어느 정도 있을 것, 목표는 스칼라로 업무가 가능한 정도까지이다.  스칼라 입문이지 프로그래밍 입문이 아닌만큼 기본 개념에 대한 설명은 생략하고 다른 언어들에서 쓰이는 개념들은 스칼라에서 어떻게 쓰는지, 함수형으로는 어떻게 같은 논리를 구현하는지에 대해 초점이 맞춰있고 스칼라2에서는 어떻게 썼는지에 대해 차이점도 소개한다. 수업을 들으면서 정리를 좀 남기긴 했지만 스칼라 문법에 대한 이야기를 굳이 요약하기보다 수업을 따라 좋은 설명을 듣기를 추천하고 스칼라 2사용자들에게 유용한 내용들만 추려보겠다.</p>
<h2 id="변경점"><a href="#변경점" class="headerlink" title="변경점"></a>변경점</h2><h3 id="indent-based-syntax-1주차"><a href="#indent-based-syntax-1주차" class="headerlink" title="indent-based syntax - 1주차"></a>indent-based syntax - 1주차</h3><p>일단 가장 큰 변화는 들여쓰기 문법을 도입하면서 중괄호(<code>&#123;&#125;</code>)를 쓸 필요가 없어졌다는 것이다. 1주차 수업부터 조건문을 설명하면서</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition then</span><br><span class="line">  expression</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  expression</span><br></pre></td></tr></table></figure>
<p>처럼 여러 줄의 표현식이 있을 때 중괄호없이 표기하는 예시를 보여준다.</p>
<h3 id="imperative-loop-2주차"><a href="#imperative-loop-2주차" class="headerlink" title="imperative-loop - 2주차"></a>imperative-loop - 2주차</h3><p>지금까지 for문(<code>for comprehension</code>)을 쓸 때, flatMap, map, withFilter 등으로 변환된다고 알고 있었는데 여기에 foreach로 변환되는 문법이 하나 추가되었다. <code>for … do</code>인데</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span></span><br><span class="line">  x &lt;- exp1</span><br><span class="line">do f(x)</span><br><span class="line"><span class="comment">// is equivalent to</span></span><br><span class="line">exp1.foreach(x =&gt; f(x))</span><br></pre></td></tr></table></figure>
<p><code>yield</code>처럼 값을 반환하지 않고 실행만 하는 명령식 반복문(imperative loop)이 생겼다.</p>
<h3 id="package-object-3주차"><a href="#package-object-3주차" class="headerlink" title="package-object - 3주차"></a>package-object - 3주차</h3><p>탑레벨(top-level) 변수들이 허용되어서 굳이 패키지 객체가 필요없긴 하지만 기능도 사라졌다.</p>
<h3 id="imports-3주차"><a href="#imports-3주차" class="headerlink" title="imports - 3주차"></a>imports - 3주차</h3><p><code>import</code> 문에서 몇가지 변화가 생겼다. 일단은 패키지 내의 멤버 전부를 가져오는게 <code>import root.from.to._</code>였는데 이제는 <code>import root.from.to.*</code>로  <code>*</code>을 사용하게 되었다. 아직 하위호환으로 <code>_</code>도 사용할 수 있다.</p>
<p>그리고 이름을 변경하여 가져올 때 <code>import from.to.&#123;Pkg =&gt; P&#125;</code>였다면 이제는 <code>as</code>라는 키워드를 사용해 <code>import from.to.&#123;Pkg as P&#125;</code>처럼 쓰면 된다.</p>
<p>새로운 <code>given</code> 키워드와 새로운 문법상 맥락이 생기며 <code>given</code> 변수들은 <code>.*</code>로 가져올 수 없으니 given을 한번에 가져오려면 <code>import from.to.given</code>을 쓰거나 given을 포함한 다른 멤버들도 한번에 가져오려면 <code>import from.to&#123;given, *&#125;</code>처럼 사용하면 된다.</p>
<h3 id="Program-Entry-Point-3주차"><a href="#Program-Entry-Point-3주차" class="headerlink" title="Program Entry Point - 3주차"></a>Program Entry Point - 3주차</h3><p>예전에는 Java처럼 <code>main(args: Array[String])</code> 메소드가 있는 Object들을 진입점들로 찾았다면 이제는 <code>@main</code>이 붙은 메소드들이 모두 진입점이 될 수 있다. 그리고 인자로 <code>@main def run(name: String, n: Int)</code>같은 식의 타입을 받으면 받은 인자들을 순서대로 저 타입 변환을 하는데 맞지않으면 실행이 되지 않는다. </p>
<h3 id="Opaque-Types-3주차"><a href="#Opaque-Types-3주차" class="headerlink" title="Opaque Types - 3주차"></a>Opaque Types - 3주차</h3><p>예전에도 데이터의 일관성을 위해 타입을 다른 이름으로 바꾸거나 다른 타입의 인자에 넣거나 trait를 붙여서 구분하는 등의 방식들이 존재했는데, 그 중에서 실행 시점에서 추가적인 리소스를 소모하지 않는 방법은 type alias가 있었지만 원래 타입으로 변환이 가능해서 <code>type UserID = Long</code>, <code>type GroupID = Long</code>이면 두 타입을 혼용하거나 원래 타입과 구분할 수 없다는 단점이 있었고 이걸 해결하기 위해 opaque type이라는 기능이 도입되었다.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">UserID</span></span>:</span><br><span class="line">  opaque <span class="class"><span class="keyword">type</span> <span class="title">UserID</span> </span>= <span class="type">Long</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(string: <span class="type">String</span>) = string.toLongOption</span><br><span class="line">  extension (id: <span class="type">UserID</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>(id: <span class="type">UserId</span>): <span class="type">Long</span> = id</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span></span>(id: <span class="type">UserID</span>): <span class="type">Option</span>[<span class="type">User</span>] =</span><br><span class="line">  ... (id.value)</span><br></pre></td></tr></table></figure>
<p>이렇게 타입에 이름을 붙이고, 원 타입과의 변환은 선언된 스코프 내에서만 가능해서 type alias와 다르게 안전하게 사용할 수 있다.</p>
<h3 id="Extension-Method-3주차"><a href="#Extension-Method-3주차" class="headerlink" title="Extension Method - 3주차"></a>Extension Method - 3주차</h3><p>위의 예제에서 <code>id.value</code>로 <code>value</code> 멤버가 없는 opaque type에 접근한 것처럼 타입을 확장할 수 있는 기능이다. 예전에는 암묵적 변환(implicit conversion)을 통해 다른 클래스로 변환하고 그 클래스의 메소드를 실행하는 방식이었는데, <code>import</code>를 통해 extension을 가져올 수 있고 특수한 경우로 <code>UserID</code>처럼 opaque type에 연결되어있으면 그 opaque type만 import하면 가져올 수 있다.</p>
<h3 id="Given-5주차"><a href="#Given-5주차" class="headerlink" title="Given - 5주차"></a>Given - 5주차</h3><p>예전에도 Context Bound라는 타입 연산자(<code>:</code>)가 있었고, 풀어서 쓰자면</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span></span>[<span class="type">A</span> : <span class="type">B</span>](a: <span class="type">A</span>)</span><br><span class="line"><span class="comment">// is equivelent to</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span></span>[<span class="type">A</span>](a: <span class="type">A</span>)(<span class="keyword">implicit</span> ev: <span class="type">B</span>[<span class="type">A</span>])</span><br></pre></td></tr></table></figure>
<p>처럼 맥락에 해당하는 묵시적 변수를 <code>implicit</code>으로 표기했는데 이제는 모든 묵시적 행동에 쓰이던 implicit이라는 키워드가 사라지고 이런 용도로는 <code>using</code>으로 쓴다. 그리고 using에서 자동으로 가져오기 위한 변수를 선언하는 키워드는 <code>given</code>이 되었다.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Ordering</span></span>:</span><br><span class="line">  given <span class="type">IntOrd</span>: <span class="type">Ordering</span>[<span class="type">Int</span>] <span class="keyword">with</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) = ...</span><br><span class="line">  given <span class="type">Ordering</span>[<span class="type">Double</span>] <span class="keyword">with</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) = ...</span><br></pre></td></tr></table></figure>
<p>이렇게 해당 given에 이름을 붙일 수도 생략할 수도 있고, <code>given intOrdering: Ordering[Int] = IntOdering</code>처럼 given이 아닌 변수지만 메소드를 제공한다면 given 변수에 할당해서 사용할 수도 있다.</p>
<p>또한 <code>implicitly</code>라고 문맥상 스코프에 존재하는 묵시적인 변수를 가져오는 함수는 이제 <code>summon</code>으로 쓴다. <code>summon[Ordering[Int]]</code>처럼 부르는데, 이것도 <code>implicitly</code>처럼 미리 선언된 함수이다.</p>
<p>given의 경우 다음과 같은 방식으로 가져올 수 있다</p>
<ul>
<li>이름:  <code>import Ordering.Int</code></li>
<li>타입:  <code>import Ordering.&#123;given Ordering[Int]&#125;</code></li>
<li>타입*: <code>import Ordering.&#123;given Ordering[?]&#125;</code></li>
<li>전부:  <code>import Ordering.given</code></li>
</ul>
<p>T 타입의 given은 다음과 같은 순서로 찾는다</p>
<ol>
<li>접근할 수 있는 given 인스턴스들</li>
</ol>
<ul>
<li>상속받았거나 import했거나 스코프 안에서 정의된 변수들</li>
</ul>
<ol start="2">
<li>T와 관련된 컴패니언 객체를 통해서</li>
</ol>
<ul>
<li>‘관련된’의 의미는<ul>
<li>T 자체의 컴패니언 객체</li>
<li>T가 상속하는 타입들의 컴패니언 객체</li>
<li>T에 있는 타입 인자들의 컴패니언 객체</li>
<li>T가 inner class라면 바깥쪽 스코프의 객체</li>
</ul>
</li>
</ul>
<p><code>given a: A</code>가 <code>given b: B</code>보다 더 구체적이다, 라는 말은</p>
<ul>
<li>a가 b보다 가까운 스코프에 있다</li>
<li>b가 정의된 클래스의 스버클래스 안에. a가 있다</li>
<li>a가 b의 서브타입이다</li>
<li>A 타입이 B 타입보다 더 “고정된” 부분이 있다.<ul>
<li><code>Ordering[Int]</code>가 <code>Ordering[?]</code>보다 더 고정되어 있다.</li>
</ul>
</li>
</ul>
<h2 id="유용한-내용"><a href="#유용한-내용" class="headerlink" title="유용한 내용"></a>유용한 내용</h2><p>sbt에 대한 설명은 아주 기본적인 것이나 아주 깊은 내용 아니면 찾기 어려워서 기본적으로 내부에서 사용하는 개념에 대해 정리된 자료를 찾기 힘든데, 3주차의 “sbt, Keys, and Scopes” 챕터에서 sbt 내에서 쓰이는 중요한 개념인 <code>Key</code>와 <code>Task</code>, 그리고 <code>Scope</code>에 대해 잘 설명해준다.</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/coursera/" class="post__tag__link">coursera</a></li><li class="post__tag__item"><a href="/tags/Scala/" class="post__tag__link">Scala</a></li></ul><a href="/2021/06/01/after-coursera-epis/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><article class="post"><header class="post__head"><time datetime="2012-11-17T11:50:00.000Z" class="post__time">November 17, 2012</time><h1 class="post__title"><a href="/2012/11/17/after-coursera-fppis-and-test/">Coursera - FPPiS 후기, 그리고 테스트</a></h1></header><div class="post__main echo"><p>coursera.org의 functional programming principle in scala의 진행이 끝났다. functional programming이라는 생소한 개념을 배우면서 재미있기도 했고, 강의를 시작하기 직전에 봤던 '자바 개발자를 위한 함수형 프로그래밍'를 읽으면서 제대로 알지 못했던 개념을 좀 더 확실하게 배웠다. 물론 강의와 서적 모두 '입문'에 대한 것이라 의미에 대해 알려면 더 많은 경험이 필요하겠고, 서적과 강의가 지향하는 바가 조금 달라서 내용도 다르지만 서적을 보면서 제대로 이해하지 못했던 개념을 강의를 보면서 이해하는데 도움이 되었고 기초가 있는 상태에서 다시 서적을 읽으면 더 이해가 잘 될 것 같다.</p>
<p>사실 강의를 읽으면서 도움이 된 것은 functional programming에 대한 이해보다 다른 것이다. 물론 functional programming에 대한 기초를 쌓는데도 무척 도움이 되었지만, 그것보다 과제를 진행하는데 있어서 '테스트'의 중요성에 대한 인식이 생겼다.</p>
<p>과제를 진행하는 방식은 이렇다.</p>
<ol>
<li>테스트 케이스가 주어진다.</li>
<li>작성해야하는 로직이 제외된 코드가 주어진다.</li>
<li>단계별로 로직을 구현하면서 테스트를 통해 작성된 로직이 유효한지 확인한다.</li>
<li>이전 단계에서 구현한 것을 기반으로 다음 단계의 로직을 작성한다.</li>
</ol>
<p>물론 주어진 테스트 케이스들 중에서 좋은 테스트 케이스만 있는 것이 아니다. 스펙에서 요구되었지만 테스트에서 확인하지 않은 케이스(정렬된 배열을 가져와야하는데 그 종류와 갯수만 확인하는 경우)는 다음 단계의 테스트를 통과하지 못한다. 그럴 경우에는 테스트에 성공한 코드로 돌아가서 수정을 해야하므로 좋은 테스트라고 볼 수 없다. 이런 식으로 좋은 테스트가 적성되어있는 경우에는 그 테스트를 통과하면 다시 그 코드를 수정할 필요가 없고, 성능상의 문제가 있는 경우에는 그 코드를 수정하고 다시 테스트를 통과하면 다른 코드들을 건들이지 않아도 된다.</p>
<p>여기에 대한 전제가 중요하긴 하다. 앞서 이야기했듯이 '좋은(명확한) 테스트가 작성되어 있을 것', 그리고 '확실히 단계별로 구분된 설계가 있을 것'이다. 이 전제들이 참 어렵지만, 반대로 생각하면 이 전제들이 확실한 경우가 있다. 바로 내가 겪었던 것과 같이 '과제'를 작성하는 경우다. 커다란 과제가 주어졌을 경우에 어디서부터 어떻게 접근해야할지 명세서를 봐도 막막한 경우가 있는데 그런 경우에 bottom-up으로 제대로 된 설계에 따라 테스트를 하나씩 거치면서 확실히 눈에 보이는 진척을 확인할 수 있다. 물론 실무에 적용하려면 저 전제들을 만족하기 참 힘들겠지만 말이다. 혹은 퍼포먼스의 이슈가 없거나 종속성이 적은 코드들의 경우에 신입사원들에게 연습시키는 용도로는 확실할 수 있다.</p>
<p>예전에 일하던 회사에서 '시켜서' 억지로 작성한 테스트들이 떠오르며 (사실 잘 떠오르지도 않지만) 부끄러워졌다. 사실 TDD라고 하지만 아직도 TDD가 뭔지 잘 모르겠고, 이해하지 못한 상태에서 작성한 테스트들은 당연히 좋은 테스트일리가 없었다. 이렇게 실무에서 어떻게 테스트를 더 잘 적용시킬 수 있는지에 대해 듣고 싶어서 저번달에 모 컨퍼런스에 다녀왔는데 그냥 '테스트는 의지를 가지고 해야 한다.'라는 말만 반복해서 하더라. 하긴 누군가가 말해줘도 그걸 체득하기는 어렵다. 계기와 경험이 중요한데 나는 일단 이 강의라는 계기를 얻었으니 앞으로 경험을 쌓도록 노력해야지.</p>
<p>참고로 80점 만점에서 60%(48점)만 얻으면 인증을 얻는데 과제를 너무 늦게 시작하는 바람에 1주차에 80% 감점을 받고 시작한 것을 합쳐서 69점으로 통과했다. 만점을 목표로 한 것에 비하면 부끄럽지만 인증을 받은 것만으로도 일단은 만족. 그리고 스칼라 스터디에 한번 참여해보고 싶었는데 영어 실력이 부족하여 참여할만큼 이해한 강의가 없어서 한번도 참여를 못한 것 두가지가 아쉽다.</p>
</div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/coursera/" class="post__tag__link">coursera</a></li><li class="post__tag__item"><a href="/tags/Scala/" class="post__tag__link">Scala</a></li><li class="post__tag__item"><a href="/tags/test/" class="post__tag__link">test</a></li></ul><a href="/2012/11/17/after-coursera-fppis-and-test/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2021 Seoh Char</div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><span title="Next" class="page-menu__link icon-arrow-right page-menu__link--disabled"></span></li></menu></footer></body></html>