<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="description" content="most opinionated blog"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="devthewild" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Coding Dojo #2 후기 - devthewild</title>
<link rel="stylesheet" href="/css/main.css">
<!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><meta name="generator" content="Hexo 5.4.0"></head><body><header class="head"><h1 class="head-title u-fl"><a href="/">devthewild</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Home</a></li><li class="head-nav__item"><a href="/archives" class="head-nav__link">Archives</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2014-08-08T15:00:00.000Z" class="post__time">August 9, 2014</time><h1 class="post__title"><a href="/2014/08/09/coding-dojo-2nd/">Coding Dojo #2 후기</a></h1></header><div class="post__main echo"><p>저번에 이은 <a target="_blank" rel="noopener" href="http://osxdev.org/forum/index.php?threads/8-6-swift-%EC%BD%94%EB%94%A9%EB%8F%84%EC%9E%A5-2%ED%9A%8C-%EA%B3%B5%EC%A7%80.373/">Coding Dojo</a>에 다녀왔다. 이번 범위는 함수에서 클로저까지.</p>
<h1>1. 스코프 내의 변수 잡기</h1>
<blockquote>
<p>클로저는 사용자의 코드 안에서 전달되거나 사용할 수 있는 기능을 포함한 독립적인 블록(block)입니다. Swift에서의 클로저는 C 및 Objective-C 의 blocks와 유사하며, 다른 언어의 람다(lambda)와도 유사합니다. 클로저는 자신이 정의된 컨텍스트(context)로부터 임의의 상수 및 변수의 참조(reference)를 획득(capture)하고 저장할 수 있습니다.</p>
<p><a target="_blank" rel="noopener" href="http://seoh.github.io/Swift-Korean/#09-closures-">09 클로저 (Closures) by inureyes</a></p>
</blockquote>
<p>for-loop(<code>for var...</code>)의 스코프에 있는 변수를 사용하는 함수를 만드는데, 해당하는 변수의 값이 스코프 내에서 계속 변하는 경우에 loop가 끝난 뒤 당연히 마지막값을 기준으로 함수가 실행되는 상황에서 현재값을 저장할 수 있는 방법에 대한 문제였다.</p>
<p>해결책은</p>
<ol>
<li>변수를 다시 캡처한다. <code>var _i = i</code></li>
<li>for-loop를 돌 때 <code>for var...</code>가 아니라 for-in으로 돌면 상수<code>let</code>가 되어 따로 캡처할 필요가 없다.</li>
<li>값을 받아서 그 값을 캡처하는 함수를 리턴하는 함수를 만든다.</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">capture</span>(<span class="params">i</span>:<span class="type">Int</span>, <span class="params">closure</span>:<span class="type">Int</span>-&gt;<span class="type">Int</span>)</span> -&gt; ()-&gt;<span class="type">Int</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sth</span>()</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> closure(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sth</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// capture(i)&#123; $0*$0 &#125;</span></span><br></pre></td></tr></table></figure>
<p>3번의 경우를 더 간단하게 만들기 위해서 JavaScript의 즉시실행함수(IIFE)를 흉내내고 싶었는데, <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/25163311/type-inference-of-iife-in-swift">Swift의 버그</a> 때문에 현재 단순히 값만 리턴하는 IIFE도 <code>var</code>는 안되고 <code>let</code>을 써야 타입 추론이 가능하며, let을 쓰더라도 함수를 리턴하는 경우에도 에러가 나고, IIFE 속에서 조건문(conditional statement)이 존재할 경우 경우의 수에 대한 superset을 추론하는게 아니라 그냥 에러가 난다.</p>
<h1>2. 부분함수와 합성함수의 단계적 구현</h1>
<h3>2.1. 기본 구현</h3>
<p>Swift에서도 함수형 프로그래밍 스타일을 지원하도록 Array에 filter, map, reduce 등의 메소드들이 존재해서 array.filter{}.map{}.reduce(){} 같은 스타일로 작성할 수 있다. 그래서 특정 조건까지의 배열을 뽑아서(<code>take</code>) filter와 map을 체이닝해서 변이(tramsform)된 배열을 구하는 문제부터 시작했다. 앞/뒤에서 특정 길이만큼 읽는 함수는 Swift의 기본 라이브러리에서 <code>prefix와</code> <code>suffix</code>를 통해 지원하고 함수형 프로그래밍에서는 보통 <code>take</code>/<code>takeRight라는</code> 이름으로 지원된다. 특정 조건까지 읽는 함수는 <code>takeWhile</code>이라고 보통 부르는데, Swift에서 구현되어있지 않아서 도장에서는 <a target="_blank" rel="noopener" href="https://github.com/pNre/ExSwift/#instance-methods">ExSwift</a>에 있는 <code>takeWhile</code>의 소스가 제공되었다.</p>
<h3>2.2. Pythonic solution</h3>
<p>Python, underscore.js처럼 filter/map/reduce라는 함수에 sequence를 인자로 넘기는 식으로 개발을 하다보면 체이닝이 아니라 reduce(map(filter(... 처럼 전역함수를 이용해 구현할 수도 있는데, 이럴 경우에는 실행되는 순서와 함수호출의 순서가 역순이고, 값을 평가하는 함수를 인자로 넘길 때 인자로 받는 전역함수와의 거리가 멀어져서 가독성이 떨어지는 문제가 생긴다. 이 문제를 부분 함수(partial function)와 합성 함수(compose function)을 이용해서 인자를 받는 순서를 바꾸면 훨씬 가독성이 올라간다.</p>
<h3>2.3. Functional Programming</h3>
<p>함수형 프로그래밍으로 구현하기 위해서는 일단 1급 시민(first-class citizen, 혹은 1급 함수나 1급 객체 등으로 불린다)이라는 개념에 대해 이해가 먼저 필요하다. Java의 경험이 있다면 <a target="_blank" rel="noopener" href="http://blog.doortts.com/135">함수형 언어로 가는 길 (중편) - 일급객체</a>, JavaScript의 경험이 있다면 <a target="_blank" rel="noopener" href="http://www.nextree.co.kr/p4150/">Javascript : 함수(function) 다시 보기</a>라는 자세한 설명의 글들이 있고 영문으로는 더 자세하고 풍부한 자료들이 있다. 그리고 함수형 프로그래밍에 대한 패러다임의 이해도 필요한데, 가장 좋은 방법은 함수형 프로그래밍을 지원하는 언어를 배우는 것이다. Twitter에서 만든 Scala School이라는 Scala 입문 강의가 있는데 <a target="_blank" rel="noopener" href="http://twitter.github.io/scala_school/ko">한글 번역</a>도 존재한다. 혹은 Java 경험이 있다면 <a target="_blank" rel="noopener" href="http://www.hanbit.co.kr/ebook/look.html?isbn=9788979149678">자바 개발자를 위한 함수형 프로그래밍</a>라는 eBook을, JavaScript 경험이 있다면 <a target="_blank" rel="noopener" href="http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-079-9">함수형 자바스크립트</a>라는 좋은 책들도 있다.</p>
<h3>2.4. Solution</h3>
<p>다시 도장 이야기로 돌아가서, 이 문제를 해결하기 위해 영후님은 F#이라는 언어의 pipe-forwarding(<code>|&gt;</code>)이라는 연산자를 구현하셨다. <a target="_blank" rel="noopener" href="http://undefinedvalue.com/2014/07/13/fs-pipe-forward-operator-swift">Swift에서의 pipe-forwarding |&gt;의 구현</a>이라는 글을 읽어보면 구현체와 그 설명이 자세히 나와있다.</p>
<p>도장에서 나온 문제와 일치하지는 않지만 위에 나온 과정들을 종합해보면 이런 예제를 만들 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">|&gt;</span>   &#123; precedence <span class="number">50</span> associativity left &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">|&gt;</span> &lt;<span class="type">T</span>,<span class="type">U</span>&gt;(<span class="params">lhs</span>: <span class="type">T</span>, <span class="params">rhs</span>: <span class="type">T</span> -&gt; <span class="type">U</span>)</span> -&gt; <span class="type">U</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> rhs(lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifilter</span>&lt;<span class="type">T</span>&gt;(<span class="params">closure</span>: <span class="type">T</span>-&gt;<span class="type">Bool</span>)</span> -&gt; [<span class="type">T</span>]-&gt;[<span class="type">T</span>] &#123;  </span><br><span class="line">    <span class="keyword">return</span> &#123; filter(<span class="variable">$0</span>, closure) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">imap</span>&lt;<span class="type">T</span>,<span class="type">S</span>&gt;(<span class="params">closure</span>: <span class="type">T</span>-&gt;<span class="type">S</span>)</span> -&gt; [<span class="type">T</span>]-&gt;[<span class="type">S</span>] &#123;  </span><br><span class="line">    <span class="keyword">return</span> &#123; map(<span class="variable">$0</span>, closure) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list <span class="operator">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  </span><br><span class="line">         <span class="operator">|&gt;</span> ifilter  &#123; <span class="variable">$0</span><span class="operator">%</span><span class="number">2</span> <span class="operator">==</span> <span class="number">0</span> &#125;</span><br><span class="line">         <span class="operator">|&gt;</span> imap     &#123; <span class="variable">$0</span><span class="operator">*</span><span class="number">2</span> &#125;</span><br><span class="line">         <span class="operator">|&gt;</span> imap     &#123; <span class="type">String</span>(<span class="variable">$0</span>) &#125;</span><br><span class="line"></span><br><span class="line">println(list) <span class="comment">// [&quot;4&quot;, &quot;8&quot;]  </span></span><br></pre></td></tr></table></figure>
<h1>3. Accumulator</h1>
<p>누산기(accumulator)는 함수 하나를 리턴하는데, 그 함수는 인자를 하나 받을 때마다 그 값들이 누산된 결과를 리턴한다. 클로저에서 값을 캡처해서 리턴하는 것은 1번 문제에서 했고, 캡처된 값을 변경하도록 하는 것과 파라미터로 정의된 값을 다시 변수로 사용해서 소스코드를 짧게 만들도록 구현하는게 목적이었다.</p>
<h1>4. Jensen's Device</h1>
<p>이번에도 알고리즘 문제가 하나 나왔다. <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Jensen's_Device">Jensen's Device</a>라는 문제로 한 변수를 캡처하고 있는 클로저를 계속 이용해서 따로 변수 선언없이 파라미터만으로 문제를 해결하도록하는 문제였다. 인자로 넘길 때 스코프 명시(<code>&#123;&#125;</code>)없이 쓸 수 있도록 해주는 <code>@auto_closure</code>라는 키워드에 대해 배웠다.</p>
<h1>5. Conclusion</h1>
<p>1회의 난이도가 1이었다면 이번 난이도는 10쯤 된다. 다음의 난이도는 얼마나 될지 모르겠다.</p>
<style type="text/css">
blockquote p:first-child { text-align: initial !important; }
blockquote p:last-child { text-align: right; }
</style></div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/swift/" class="post__tag__link">swift</a></li><li class="post__tag__item"><a href="/tags/osxdev/" class="post__tag__link">osxdev</a></li></ul><a href="/2014/08/09/coding-dojo-2nd/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2021 Seoh Char</div><menu class="page-menu u-fr"><li class="page-menu__item"><a title="Previous" href="/2014/09/10/prototyping-swipe-and-drag-gestures-with-framer-3/" class="page-menu__link icon-arrow-left"></a></li><li class="page-menu__item"><a title="Next" href="/2014/07/24/coding-dojo-1st/" class="page-menu__link icon-arrow-right"></a></li></menu></footer></body></html>