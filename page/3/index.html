<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="description" content="most opinionated blog"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/blog/rss.xml" title="devthewild" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>devthewild</title><link rel="stylesheet" href="/blog/css/main.css" type="text/css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--></head><body><header class="head"><h1 class="head-title u-fl"><a href="/blog/">devthewild</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/blog/" class="head-nav__link">Home</a></li><li class="head-nav__item"><a href="/blog/archives" class="head-nav__link">Archives</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2012-09-01T12:50:00.000Z" class="post__time">1st Sep, 2012</time><h1 class="post__title"><a href="/blog/2012/09/01/coding-interview-p149-3-c/">문제로 풀어보는 알고리즘 149쪽 문제 3.c 풀이</a></h1></header><div class="post__main echo"><blockquote>
<p>자연수 n을 입력받아 집합 {0, 1, 2, …, n-1}을 하나 이상의 집합으로 나누는 방법을 모두 출력하는 프로그램을 작성하세요.
[실행 예]
input n: 3
{0, 1, 2}
{0} {1, 2}
{1} {0, 2}
{2} {0, 1}
{0} {1} {2}</p>
</blockquote>
<blockquote>
<ul>
<li>참고 *</li>
</ul>
<ol>
<li>n의 범위는 크게 상관이 없지만, 대략 16 이하라고 가정하시면 되겠습니다. ^^</li>
</ol>
</blockquote>
<ol start="2">
<li>집합으로 나눈 경우를 출력하는 방법은 상관없습니다.</li>
</ol>
<ul>
<li>{1} {0, 2}를 {0, 2} {1}로 표현해도 되고, 1, 0 2로 표현해도 됩니다. (다른 형식도)</li>
<li>또, {0} {1, 2}가 먼저 출력되든, {0} {1} {2}가 먼저 출력되든 상관 없습니다. 빠짐없이 출력하기만 하면 됩니다.</li>
</ul>
<p>곰곰히 생각해서 나름대로 잘 풀었다고 생각했는데 다른 사람들의 풀이를 보니 다 똑같아서 알고리즘의 설명은 생략하겠다. 그 대신에 잠깐 생각해본게 과연 이렇게 하나씩 추가하는 알고리즘에서 중복(순서가 바뀐 같은 집합)이 존재하지 않을까? 하는 의문이다. { ArrayN, ArrayM, ... } 이렇게 부분집합 n, m 이 있을 때 { ArrayM, ArrayN, ... } 라고 순서가 바뀐 다른 부분집합이 있을까? 답은 없다. n에서 제일 작은 n[0]과 m에서 제일 작은 m[0]가 있을 때 n[0] &lt; m[0]라면 항상 n[0]가 앞에 있는 집합에 속해있다. 크기 순서대로 입력이 된다고 가정했을 때 m[0]가 n[0]보다 앞에 있으려면 n[0]보다 작은 숫자가 먼저 입력되어있는 부분 집합에 m[0]가 속해야하는데 그럼 그 집합에서 가장 작은 숫자가 m[0]가 아니기 때문에 모순되므로 m[0]가 n[0]보다 앞에 올 수 없어서 중복된 집합은 존재하지 않는다.</p>
<p>그리고 coffeescript를 실행할 때 compile하고 다시 node로 실행시키는 일을 두번 하기 싫은데 coffee에서 직접 파일을 입력받아 실행시키는 옵션은 없고 stdio로 script text를 받아서 실행시키는 옵션은 있어서 출력한 뒤 파이프로 넘기게 계속 명령어를 입력했는데 (cat test.coffee | coffee -s) argument를 입력받게 되니 coffee파일까지 커서를 옮겼다가 다시 argument로 커서를 옮겼다가 하기 귀찮아서 bash script 문서를 구글링해서 하나 만들었다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> <span class="operator">-lt</span> <span class="number">1</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"you must give me coffee"</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">cat <span class="variable">$1</span> | coffee <span class="operator">-s</span> <span class="variable">$&#123;@:2&#125;</span></span><br></pre></td></tr></table></figure>
<p>중요한건 이게 아니고 다시 문제로 돌아가서 소스를 보자면</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># subset.coffee</span></span><br><span class="line">n = parseInt process.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">Array.prototype.clone = <span class="function"><span class="params">()</span> -&gt;</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="keyword">this</span></span><br><span class="line">        item = item.clone() <span class="keyword">if</span> item.constructor <span class="keyword">is</span> Array</span><br><span class="line">        ret.push item</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">data = [ [[<span class="number">0</span>]] ]</span><br><span class="line"><span class="function"></span><br><span class="line"><span class="title">add</span> = <span class="params">(arr, n)</span> -&gt;</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> arr</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0.</span>..row.length]</span><br><span class="line">            (c = row.clone())[i].push n</span><br><span class="line">            ret.push c</span><br><span class="line">        row.push [n]</span><br><span class="line">        ret.push row</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1.</span>..n]</span><br><span class="line">    data = add data, i</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log data</span><br></pre></td></tr></table></figure>
<p>그리고 실행</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(21:58:11) coffee seoh$ ./c.sh subset.coffee 4</span><br><span class="line"><span class="comment">[ <span class="comment">[ <span class="comment">[ 0, 1, 2, 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 1, 2 ]</span>, <span class="comment">[ 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 1, 3 ]</span>, <span class="comment">[ 2 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 1 ]</span>, <span class="comment">[ 2, 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 1 ]</span>, <span class="comment">[ 2 ]</span>, <span class="comment">[ 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 2, 3 ]</span>, <span class="comment">[ 1 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 2 ]</span>, <span class="comment">[ 1, 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 2 ]</span>, <span class="comment">[ 1 ]</span>, <span class="comment">[ 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 3 ]</span>, <span class="comment">[ 1, 2 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0 ]</span>, <span class="comment">[ 1, 2, 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0 ]</span>, <span class="comment">[ 1, 2 ]</span>, <span class="comment">[ 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0, 3 ]</span>, <span class="comment">[ 1 ]</span>, <span class="comment">[ 2 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0 ]</span>, <span class="comment">[ 1, 3 ]</span>, <span class="comment">[ 2 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0 ]</span>, <span class="comment">[ 1 ]</span>, <span class="comment">[ 2, 3 ]</span> ]</span>,</span><br><span class="line">  <span class="comment">[ <span class="comment">[ 0 ]</span>, <span class="comment">[ 1 ]</span>, <span class="comment">[ 2 ]</span>, <span class="comment">[ 3 ]</span> ]</span> ]</span></span><br></pre></td></tr></table></figure>
<p>cat test.coffee | coffee -s로 실행을 하면 내부적으로 어떤 구조로 node를 실행시키는지 모르겠지만 [ 'node', '.', '-s' ] 라는 세 argument가 기본적으로 붙는다. 그런데 -s는 help에도 안나오고 직접 node -s로 하면 unrecognized flag라고 나오고. 뭔지 모르겠지만 귀찮아서 패스.</p>
<p>사실 처음에는 다른 방법으로 접근했다가 포기했다. 어차피 모든 부분집합의 원소의 합은 n으로 일정하니 일단 그 크기를 나누는 것을 n=4일 때를 예로 들어,</p>
<p>4
3 + 1
2 + 2
2 + 1 + 1
1 + 1 + 1 + 1</p>
<p>로 나타낼 수 있다. 각 행마다 하나씩 예로 들자면</p>
<p>{ 0, 1, 2, 3 }
{ 0, 1, 2 }, { 3 }
{ 0, 1 }, { 2, 3 }
{ 0, 1 }, { 2 } , { 3 }
{ 0 }, { 1 }, { 2 }, { 3 }</p>
<p>로 나타낼 수 있다. 그래서</p>
<figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># split.coffee</span></span><br><span class="line">n = parseInt process.argv[<span class="number">3</span>]</span><br><span class="line"><span class="function"></span><br><span class="line"><span class="title">split</span> = <span class="params">(n)</span> -&gt;</span></span><br><span class="line">    split.ret.clear</span><br><span class="line">    split.arr.clear</span><br><span class="line"></span><br><span class="line">    __split(n, <span class="number">0</span>, n)</span><br><span class="line">    split.ret</span><br><span class="line"></span><br><span class="line">split.arr = []</span><br><span class="line">split.ret = []</span><br><span class="line"><span class="function"></span><br><span class="line"><span class="title">__split</span> = <span class="params">(n, i, m)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line">        split.ret.push split.arr.slice(<span class="number">0</span>, i)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> m &gt; n</span><br><span class="line">        m = n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">1</span> .. m]</span><br><span class="line">        split.arr[i] = j</span><br><span class="line">        __split n-j, i+<span class="number">1</span>, j</span><br><span class="line"></span><br><span class="line">n &amp;&amp; <span class="built_in">console</span>.log split n</span><br><span class="line">exports &amp;&amp; exports.split = split</span><br></pre></td></tr></table></figure>
<p>라고 [1.6 수분할] 챕터를 참고해서 만들었다. 그런데 이걸 깔끔하게 정리해서 개수를 맞춰서 경우의 수를 만들 수 있는 방법을 못찾아서 다른 방법을 강구하게 되었다. 단순히 생각했을 때, memoization처럼 <code>memo['2.1.1']['2'].indexOf('1.2')</code>라는 식으로 2+1+1을 '2.1.1'로 {1, 2}는 '1.2'처럼 문자열로 만들어서 HashMap을 하나 만들면 구현은 편한데 어차피 모든 경우의 수를 만들고 거기에서 필터링하는거나 마찬가지라 (정확히 말하면 '가지치기'의 방법이 떠오르지 않아서) 비효율적이라 포기했다. 나중에 시간나면 지금처럼 bottom-up같은 방법이 아니라 top-down으로 할 수 있는 방법이 없나 찾아봐야겠다.</p>
</div><footer class="post__foot u-cf"><a href="https://github.com/seoh/blog/tree/master/source/_posts/coding-interview-p149-3-c.md" class="post__foot-link u-fr">Pull Request</a><a href="https://github.com/seoh/blog/issues/new" class="post__foot-link u-fr">Tell me</a></footer></article><article class="post"><header class="post__head"><time datetime="2012-08-30T07:40:00.000Z" class="post__time">30th Aug, 2012</time><h1 class="post__title"><a href="/blog/2012/08/30/coding-interview-0-3/">문제로 풀어보는 알고리즘 0.3 생각해보기 풀이</a></h1></header><div class="post__main echo"><figure class="highlight coffee"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rotate.coffee</span></span><br><span class="line">arr = [<span class="number">1.</span>.<span class="number">8</span>]</span><br><span class="line">s = <span class="number">2</span></span><br><span class="line">t = <span class="number">6</span></span><br><span class="line"><span class="function"></span><br><span class="line"><span class="title">rotate</span> = <span class="params">(k)</span> -&gt;</span></span><br><span class="line">    len = t-s+<span class="number">1</span></span><br><span class="line">    k = k % len</span><br><span class="line">    __rotate k, s, len</span><br><span class="line"><span class="function"></span><br><span class="line"><span class="title">__rotate</span> = <span class="params">(k, i, len)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">if</span> len <span class="keyword">is</span> <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span></span><br><span class="line">    temp = arr[i]</span><br><span class="line">    next = (i-s+k) % (t-s+<span class="number">1</span>) + s</span><br><span class="line">    __rotate(k, next, len-<span class="number">1</span>)</span><br><span class="line">    arr[next] = temp</span><br><span class="line"></span><br><span class="line">rotate <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log arr <span class="comment"># [ 1, 2, 7, 3, 4, 5, 6, 8 ]</span></span><br></pre></td></tr></table></figure>
<p>CoffeeScript를 튜토리얼만 살짝 읽고 언젠가 써봐야지하면서 쓸 일이 없었는데 겸사겸사 이번 기회에 써봤다. 분명 타자는 더 적어진거 같은데 손에 안익어서 문서를 보면서 코딩해서 그런지 시간은 더 늘어난 기분. 튜토리얼말고 제대로 된 문서를 정독하고 나서 나중에 다시 도전해봐야겠다.</p>
<blockquote>
<p>배열 arr[]과 위치 s, t가 있을 때,
arr[s], arr[s+1], … , arr[t-1]을 오른쪽으로 한 칸씩 이동하고,
arr[t]는 arr[s]로 복사하는 것을 ’1만큼 오른쪽으로 회전시켰다’고 한다.
예를 들어 길이가 8인 배열에서 s=2, t=6이면 다음 그림처럼 바뀐다.
<img src="http://www.insightbook.co.kr/wp-content/uploads/2012/08/%EA%B7%B8%EB%A6%BC-0-1.jpg" alt="">
길이가 n인 배열의 위치는 0, 1, 2, … , n-1이다.
문제 :
k를 인자로 받아서 k만큼 오른쪽으로 회전시키는 함수를 작성하라.
단, 1만큼 오른쪽으로 이동시키는 과정을 k번 반복해서는 안 된다.
조건 1 : 작성하는 언어에는 제한이 없습니다.
조건 2 : 답안으로 작성하신 글 제목에는 ‘문제로 풀어보는 알고리즘 0.3 생각해보기 풀이’라는 문장이 들어가야 합니다. (저희 블로그에도 트랙백을 걸어주세요.)
(주의: 이 코딩 인터뷰는 인사이트 입사와는 무관합니다. ㅡㅁㅡ /)</p>
</blockquote>
<p>문제에 대해서 접근하자면, 간단하게 생각해서 마지막 숫자를 저장해두고 그 자리에 올 숫자를 마지막 숫자의 자리에 옮기고, 이걸 (t-s+1-1)번 (실제 옮겨지는 아이템의 수 -1) 옮기고 나서 처음에 저장해두었던 숫자를 k만큼 이동하면 된다. 그런데 모듈러 연산이라는게 역산하기 어려운고로 제일 쉬운 방법은 옮길 아이템의 수 (t-s+1) 만큼 공간을 만들고 값을 복사한 뒤에 그림에 나온 것처럼 t-s+1번 이동하는 방법이 제일 간단하고 명확했다. 그런데 몇줄 안나오는 코드로는 재미가 없어서 지금 있는 공간에서 해결할 수 있는 방법을 찾다가 요즘 읽고 있는 그 책에서 자꾸 재귀적인 알고리즘을 강요하듯 반복해서 재귀적으로만 풀이하니 전염이 되었나 한번 재귀적으로 풀어보고 싶었다.</p>
<p>단순하게 생각해서 arr만 가지고 풀기를 시도해보면, [2]에 있는 3을 [3]으로 옮기려한다. 그럼 [3]에 있는 4가 사라지니 3을 일단 메모리에게 들고 있으라고 한 뒤에 4부터 옮기고 3을 [3]에 넣으면 될 것이다. 이런 식으로 들어가야할 자리가 비어있지 않으면 잠시 메모리에 놓고 다음꺼부터 옮기다가 자리가 비어있으면 (t-s+1 번만큼 호출된 후에) 그냥 이동만 하고 아까 메모리에 놔두었던 것들을 원하는 자리에 차례대로 넣으면 된다. 문제는 이런 경우에 자료의 크기 자체에 더해서 call stack만큼의 비용을 추가로 부담하게 되니, 메모리 사용이 4*k에서 (4+@)*k로 늘어나게 되니 오히려 더 비효율적이 될 수도 있고, heap보다 stack이 조금 더 빠르니 비슷할 수도 있다. 원래의 의도는 그냥 재귀적으로 도전해보는 것이었으니 그 이상은 여기까지 생각하고 잘 돌아가는 것에서 만족하도록 하자.</p>
</div><footer class="post__foot u-cf"><a href="https://github.com/seoh/blog/tree/master/source/_posts/coding-interview-0-3.md" class="post__foot-link u-fr">Pull Request</a><a href="https://github.com/seoh/blog/issues/new" class="post__foot-link u-fr">Tell me</a></footer></article></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2015 Seoh Char</div><menu class="page-menu u-fr"><li class="page-menu__item"><a title="Previous" href="/blog/page/2/" class="page-menu__link icon-arrow-left"></a></li><li class="page-menu__item"><span title="Next" class="page-menu__link icon-arrow-right page-menu__link--disabled"></span></li></menu></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-52090105-1');ga('send','pageview');
</script></body></html>